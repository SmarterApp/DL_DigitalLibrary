<?php
/**
 * @file
 * Code for the SBAC LDAP feature.
 */

include_once 'sbac_ldap.features.inc';

/**
 * Implements hook_update_projects_alter().
 *
 * @param $projects
 */
function sbac_ldap_update_projects_alter(&$projects) {
  unset($projects['sbac_ldap']);
}

/**
 * Implements hook_form_alter().
 *
 * @param $form
 * @param $from_state
 * @param $form_id
 */
function sbac_ldap_form_alter(&$form, &$from_state, $form_id) {
  if ($form_id == 'user_login') {
    $form['#validate'][] = 'sbac_ldap_login_validate';
  }
}

/**
 * Validate handler for login.
 *
 * @param $form
 * @param $form_state
 */
function sbac_ldap_login_validate(&$form, &$form_state) {
  $error = sbac_ldap_test_connect();
  $logged_in = user_is_logged_in();
  if ($error || (!$logged_in)) {
    $messages = drupal_get_messages(NULL, FALSE);
    if (isset($messages['error'])) {
      foreach ($messages['error'] as $key => $message) {
        if (strpos($message, 'Sorry, unrecognized username or password') !== FALSE) {
          drupal_get_messages('error');
          if ($error)
            drupal_set_message('User authentication is currently unavailable. Please try again in a few minutes', 'error');
          elseif (!$logged_in)
            drupal_set_message('Your email address or password was not recognized.', 'error');
          else {}
          break;
        }
      }
    }
  }
}

/**
 * Tests that the LDAP server is up and running.
 *
 * @return bool
 */
function sbac_ldap_test_connect() {
  if (!$auth_conf = ldap_authentication_get_valid_conf()) {
    return TRUE;
  }

  if (!$auth_conf->hasEnabledAuthenticationServers()) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implementation of hook_user_import_after_save().
 */
function sbac_ldap_user_import_after_save($settings, $account, $password, $fields, $updated, $update_setting_per_module) {
  $fields_data = isset($fields['field']) ? $fields['field'] : array();

  if (empty($fields_data)) return;

  $processors       = field_user_import_supported_fields();
  $delimiter        =  $settings['multi_value_delimiter'];
  $user_fields      = user_load($account->uid);
  $processed_fields = array();

  foreach ($fields_data as $field_name => $data) {
    $field_info         = field_info_field($field_name);
    $field_type         = $field_info['type'];
    $processor_function = $processors[$field_type]['save'];

    // Deal with multiple values.
    $values = explode($delimiter, $data[0]);
    
    if ($field_name == 'field_state'){
      $field_state = $processor_function($user_fields, $field_name, $values);
      $states_vocab = taxonomy_vocabulary_machine_name_load('states');
      foreach ($field_state['und'] as &$state) {
        $terms = taxonomy_get_term_by_name($state['value']);
        foreach ($terms as $term) {
          if($term->vid == $states_vocab->vid){
            $state['tid'] = $term->tid;
            break;
          }
        }  
      }
      $processed_fields[$field_name] = $field_state;
    }
    elseif ($field_name == 'field_position'){
      $field_state = $processor_function($user_fields, $field_name, $values);
      $states_vocab = taxonomy_vocabulary_machine_name_load('title');
      foreach ($field_state['und'] as &$state) {
        $terms = taxonomy_get_term_by_name($state['value']);
        foreach ($terms as $term) {
          if($term->vid == $states_vocab->vid){
            $state['tid'] = $term->tid;
            break;
          }
        }  
      }
      $processed_fields[$field_name] = $field_state;
    }
    elseif ($field_name == 'field_special_populations'){
      $field_state = $processor_function($user_fields, $field_name, $values);
      $states_vocab = taxonomy_vocabulary_machine_name_load('intended_student_populations');
      foreach ($field_state['und'] as &$state) {
        $terms = taxonomy_get_term_by_name($state['value']);
        foreach ($terms as $term) {
          if($term->vid == $states_vocab->vid){
            $state['tid'] = $term->tid;
            break;
          }
        }  
      }
      $processed_fields[$field_name] = $field_state;
    }
    elseif ($field_name == 'field_subject_s_'){
      $field_state = $processor_function($user_fields, $field_name, $values);
      $states_vocab = taxonomy_vocabulary_machine_name_load('subject');
      foreach ($field_state['und'] as &$state) {
        $terms = taxonomy_get_term_by_name($state['value']);
        foreach ($terms as $term) {
          if($term->vid == $states_vocab->vid){
            $state['tid'] = $term->tid;
            break;
          }
        }  
      }
      $processed_fields[$field_name] = $field_state;
    }
    elseif ($field_name == 'field_grade_level_s_'){
      $field_state = $processor_function($user_fields, $field_name, $values);
      $states_vocab = taxonomy_vocabulary_machine_name_load('grades');
      foreach ($field_state['und'] as &$state) {
        $terms = taxonomy_get_term_by_name($state['value']);
        foreach ($terms as $term) {
          if($term->vid == $states_vocab->vid){
            $state['tid'] = $term->tid;
            break;
          }
        }  
      }
      $processed_fields[$field_name] = $field_state;
    }
    else {
      // Use callback function to process info for field before saving.
      $processed_fields[$field_name] = $processor_function($user_fields, $field_name, $values);
    }
  }

  if (!empty($processed_fields)) {
    user_save($account, $processed_fields);
  }

  return;
}




