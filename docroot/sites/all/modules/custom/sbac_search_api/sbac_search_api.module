<?php
/**
 * @file
 * Code for the SBAC Search API feature.
 */

include_once 'sbac_search_api.features.inc';

/**
 * Implements hook_workbench_moderation_transition().
 *
 * This will trigger a re-index of this item when it's workbench status changes.
 */
function sbac_search_api_workbench_moderation_transition($node, $previous_state, $new_state) {
  if (module_exists('search_api')) {
    if ($previous_state != $new_state) {
      search_api_track_item_change('node', array($node->nid));
      $combined_id = 'node/' . $node->nid;
      search_api_track_item_change('multiple', array($combined_id));
    }
  }
}

/**
 * Implements hook_entity_property_info_alter().
 *
 * This will add a "Workbench moderation state" field to any moderated entities via a callback.
 */
function sbac_search_api_entity_property_info_alter(&$info) {
  foreach (array_keys($info['node']['bundles']) as $bundle) {
    if (workbench_moderation_node_type_moderated($bundle)) {
      $info['node']['bundles'][$bundle]['properties']['workbench_moderation_state'] = array(
        'type' => 'text',
        'label' => t('Workbench moderation state'),
        'getter callback' => 'sbac_search_api_property_workbench_moderation_state_getter_callback',
        'sanitized' => TRUE,
      );
    }
  }
}

/**
 * Getter callback to return current workbench moderation state.
 */
function sbac_search_api_property_workbench_moderation_state_getter_callback($node) {
  $state = workbench_moderation_state_none();
  if (isset($node->workbench_moderation['current']->state)) {
    $state = $node->workbench_moderation['current']->state;
  }
  elseif ($node->status == NODE_PUBLISHED) {
    $state = workbench_moderation_state_published();
  }

  return workbench_moderation_state_label($state);
}

/**
 * Implements hook_facetapi_facet_info_alter().
 *
 * We're adding our own label mapper here to exclude any deleted taxonomy terms.
 */
function sbac_search_api_facetapi_facet_info_alter(array &$facet_info, array $searcher_info) {
  // Only do this if it is the Search API facets.
  if ($searcher_info['adapter'] == 'search_api') {
    // Go through the fields and only do this to the taxonomy terms.
    foreach ($facet_info as $bundle => $info) {
      if ($info['field type'] == 'taxonomy_term') {
        // Store the original mapper so we can use that as a starting point and won't have to rewrite it all.
        $facet_info[$bundle]['map options']['upstream mapper'] = $facet_info[$bundle]['map callback'];
        // Replace that mapper with ours.
        $facet_info[$bundle]['map callback'] = 'sbac_search_api_facetapi_map_callback';
      }
    }
  }
}

/**
 * Map Callback to exclude missing taxonomy terms.
 *
 * @param $values
 * @param $options
 * @return array|mixed
 */
function sbac_search_api_facetapi_map_callback($values, $options) {
  $map = array();

  // Start with the original mapper.
  if (isset($options['upstream mapper']) && is_callable($options['upstream mapper'])) {
    $map = call_user_func($options['upstream mapper'], $values, $options);
  }

  // Make all of the indexed IDs the keys so we can compare them to the already mapped items ($map is id => label).
  $ids = array_flip($values);
  // Get the items that have not been mapped, which means a label couldn't be found, which means they don't exist.
  $diff = array_diff_key($ids, $map);
  // Set all of those items to NULL, as the facet_api module will interpret this as the item should be excluded.
  // This requires the dev version of facet_api (see https://www.drupal.org/node/2545130).
  foreach ($diff as $k => $d) {
    $diff[$k] = NULL;
  }
  // Add the two arrays together and we have our final map.
  $map = $map + $diff;
  return $map;
}

/**
 * Invalidates the cached search pre-filter URL data.
 */
function _sbac_search_api_invalidate_pre_filter_cache() {
  unset($_SESSION['user_pre_filters']);
}

/**
 * Sets the cached search pre-filter URL data.
 *
 * @param $value string The URL data to cache
 */
function _sbac_search_api_set_pre_filter_cache($value) {
  $_SESSION['user_pre_filters'] = $value;
}

/**
 * Returns the cached search pre-filter URL data.
 *
 * @return bool|string The cached search pre-filter URL data if set, false otherwise
 */
function _sbac_search_api_get_pre_filter_cache() {
  if (isset($_SESSION['user_pre_filters'])) {
    return $_SESSION['user_pre_filters'];
  }
  return FALSE;
}

/**
 * Checks to see of a tid is set in a taxonomy term reference field.
 *
 * @param $entity Entity
 * @param $field string Name of the field to search
 * @param $value int TID to search for
 * @return bool
 */
function _sbac_search_api_term_check($entity, $field, $value) {
  foreach ($entity->{$field}[LANGUAGE_NONE] as $info) {
    if ($info['tid'] == $value) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Returns a FacetAPI Pretty URL set of filters to default users to the subject(s) and grade(s) in their profile.
 *
 * @return bool|string
 */
function _sbac_search_api_get_pre_filters() {
  // Only run through this if the cache isn't valid.
  if (!$filters = _sbac_search_api_get_pre_filter_cache()) {
    global $user;
    $filters = '';
    // Don't do this for anon users.
    if (user_is_logged_in()) {
      // We need this to get the pretty taxonomy names.
      require_once drupal_get_path('module', 'pathauto') . '/pathauto.inc';

      $account = user_load($user->uid);

      // Get the pretty aliases instead of hard-coding them in here in case they change.
      $adapter = facetapi_adapter_load('search_api@default_node_index');
      $processor = new FacetapiUrlProcessorPrettyPaths($adapter);
      $facets = facetapi_get_facet_info('search_api@default_node_index');
      $subject_alias = $processor->getFacetPrettyPathsAlias($facets['field_subject']);
      $grade_alias = $processor->getFacetPrettyPathsAlias($facets['field_grades']);

      // Get the subject and grade TIDs for the user, and process them into the URL.
      $fields = array('field_subject_s_' => $subject_alias, 'field_grade_level_s_' => $grade_alias);
      foreach ($fields as $field => $alias) {
        foreach ($account->{$field}[LANGUAGE_NONE] as $key => $info) {
          $term = taxonomy_term_load($info['tid']);
          // Only add the child terms if their parent isn't set.
          if (!($term->parent && _sbac_search_api_term_check($account, $field, $term->parent))) {
            // Get the pretty taxonomy name
            $name = pathauto_cleanstring($term->name);
            // Put together the URL using the FacetAPI Pretty rule.
            $filters .= "/$alias/" . "$name-" . $term->tid;
          }
        }
      }
      // Set the cache.
      _sbac_search_api_set_pre_filter_cache($filters);
    }
  }
  return $filters;
}
