<?php

/**
 * @file.
 * Module to handle all central functions related to this project.
 *
 * Provides:
 *  - Common functions that are called throughout the custom codebase
 *  - A central repository of install scripts that enable site wide configurations
 *  - Exports common site wide configurations
 */

include_once 'sbac_central.features.inc';

/**
 * Implements hook_update_projects_alter().
 *
 * @param $projects
 */
function sbac_central_update_projects_alter(&$projects) {
  unset($projects['sbac_central']);
}

/**
 * Implements hook_entity_info_alter().
 */
function sbac_central_entity_info_alter(&$entity_info) {
  if (isset($entity_info['node']['entity cache'])) {
    $entity_info['node']['entity cache'] = FALSE;
    $entity_info['node']['controller class'] = 'NodeController';
    $entity_info['node']['field cache'] = TRUE;
  }
  if (isset($entity_info['file']['entity cache'])) {
    $entity_info['file']['entity cache'] = TRUE;
    $entity_info['file']['controller class'] = 'DrupalDefaultEntityController';
    $entity_info['file']['field cache'] = TRUE;
  }
  if (isset($entity_info['taxonomy_vocabulary']['entity cache'])) {
    $entity_info['taxonomy_vocabulary']['entity cache'] = FALSE;
    $entity_info['taxonomy_vocabulary']['controller class'] = 'TaxonomyVocabularyController';
    $entity_info['taxonomy_vocabulary']['field cache'] = TRUE;
  }
  if (isset($entity_info['user']['entity cache'])) {
    $entity_info['user']['entity cache'] = TRUE;
    $entity_info['user']['controller class'] = 'UserController';
    $entity_info['user']['field cache'] = TRUE;
  }
}

function sbac_central_menu() {
  $items = array();

  $items['sbac-central-fix-broken-ccss'] = array(
    'title' => 'My Resources',
    'page callback' => 'sbac_central_fix_broken_ccss',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/sbac/sbac-central'] = array(
    'title' => 'Central Configuration',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sbac_central_google_cdn_admin'),
    'access arguments' => array('administer sbac_central settings'),
    'file'=> 'sbac_central.admin.inc',
    'type' => MENU_NORMAL_ITEM,
   );
  $items['admin/sbac/sbac-central/google-cdn'] = array(
    'title' => 'Google CDN Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );

  $items['admin/sbac/sbac-central/oscaddie'] = array(
    'title' => 'osCaddie Settings',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sbac_central_google_cdn_admin'),
    'file'=> 'sbac_central.admin.inc',
    'access arguments' => array('administer sbac_central')
  );

  $items['admin/sbac/sbac-central/google-cdn-migrate'] = array(
    'title' => 'Google CDN Migrate',
    'description' => 'Migrates old files to new Google CDN',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sbac_central_google_cdn_migrate_admin'),
    'file'=> 'sbac_central.admin.inc',
    'access arguments' => array('administer sbac_central'),
    'weight' => 50
  );

  return $items;
}

/**
 * Implements permissions().
 */
function sbac_central_permission() {
  return array(
    'administer sbac_central' => array(
      'title' => t('Administer SBAC Central'),
      'description' => t('Perform administration tasks for SBAC Central.'),
    ),
  );
}

/**
 * Script to fix broken ccss. yay...
 */
function sbac_central_fix_broken_ccss() {
  ini_set('max_execution_time', 900);
  ini_set('memory_limit', '1024M');
  $vid = 11; //same across all environments.

  if (isset($_GET['debug']) && $_GET['debug'] == 1) {
    $debug = TRUE;
  }
  else {
    $debug = FALSE;
  }

  $LOGFILE = "/tmp/sbac_ccss_migration.". date("Ymd-His", time()) .".log";
  $logmsg = "Starting ccss migraiton\n";
  if ($debug) {
    $logmsg .= "Operating in debug mode\n";
  }
  else {
    $logmsg .= "Operating in live mode\n";
  }

  // only get items up till oct.28th (before the push).
  $sql = "SELECT n.nid AS nid FROM {node} n WHERE n.type = 'alignment' AND n.changed <= 1382943600";
  $result = db_query($sql);
  foreach ($result as $row) {
    $node = node_load($row->nid);
    if ($node) {
      if (isset($node->field_education_alignment['und'][0])) {
        $logmsg .= "Selected node->title: " . $node->title . " node->nid: " . $node->nid . "\n";
        $tid = $node->field_education_alignment['und'][0]['tid'];
        db_set_active('sbac_prod_old');
        $sql2 = "SELECT * FROM {taxonomy_term_data} WHERE tid = :tid AND vid = :vid";
        // only select a TID with the given VID, to ensure its the correct vocab.
        $results2 = db_query($sql2, array(':tid' => $tid, ':vid' => $vid))->fetchAssoc();
        if ($results2) {
          $logmsg .= "Selected term id from old db (tid = " . $tid . ")\n";
          $old_term = taxonomy_term_load($results2['tid']);
          // have the old data, now find it in the new db.
          db_set_active();
          $sql3 = "SELECT * FROM taxonomy_term_data td
            JOIN field_data_field_alignment_grade fag ON td.tid = fag.entity_id
            JOIN field_data_field_alignment_key fak ON td.tid = fak.entity_id
            JOIN field_data_field_alignment_publication fap ON td.tid = fap.entity_id
            JOIN field_data_field_alignment_shortname fas ON td.tid = fas.entity_id
            WHERE fag.field_alignment_grade_value = :grade
            AND fak.field_alignment_key_value = :key
            AND fap.field_alignment_publication_value = :publication
            AND fas.field_alignment_shortname_value = :shortname";

          $grade = $old_term->field_alignment_grade['und'][0]['value'];
          $key = $old_term->field_alignment_key['und'][0]['value'];
          $publication = $old_term->field_alignment_publication['und'][0]['value'];
          $shortname = $old_term->field_alignment_shortname['und'][0]['value'];
          $results3 = db_query($sql3, array(
            ':grade' => $grade,
            ':key' => $key,
            ':publication' => $publication,
            ':shortname' => $shortname
          ))->fetchAssoc();

          if ($results3) {
            //This is the new tid.
            if ($debug) {
              $logmsg .= "Did not save tid (" . $results3['tid'] . "), operating in debug mode\n";
            }
            else {
              $logmsg .= "Saved new tid (" . $results3['tid'] . ") to the node\n";
              $node->field_education_alignment['und'][0]['tid'] = $results3['tid'];
              node_save($node);
            }
          }
          else {
            $logmsg .= "Unable to select term id from new db with the following info:\n";
            $logmsg .= "grade: " . $grade . "\n";
            $logmsg .= "key: " . $key . "\n";
            $logmsg .= "publication: " . $publication . "\n";
            $logmsg .= "shortname: " . $shortname . "\n";
          }
        }
        else {
          $logmsg .= "Unable to select term id from old db (tid = " . $tid . ")\n";
        }
        db_set_active();
      }
    }
  }
}

/**
 * Implements hook_init().
 * Enables/disables maillog per environment.
 */
function sbac_central_init() {
  drupal_add_http_header('X-Frame-Options', 'SAMEORIGIN');
  drupal_add_http_header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  drupal_add_http_header('X-Content-Type-Options', 'nosniff');
  drupal_add_http_header('X-XSS-Protection', '1;mode=block');
}


/**
 * Determines the users most priveleged role.
 *
 * @param null $account
 * @return bool
 */
function sbac_central_determine_user_role($account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  $role = FALSE;
  $weighted_roles = array();
  $system_roles = sbac_central_user_roles();
  foreach ($account->roles AS $rid => $role_name) {
    $weighted_roles[$system_roles[$rid]->weight] = $system_roles[$rid];
  }

  if ($weighted_roles) {
    $max_weight = max(array_keys($weighted_roles));
    $role = $weighted_roles[$max_weight];
  }
  return $role;
}

/**
 * Returns user roles with weight.
 *
 * @return array
 */
function sbac_central_user_roles() {
  $query = db_select('role', 'r');
  $query->fields('r', array('rid', 'name', 'weight'));
  $query->orderBy('weight');
  $result = $query->execute();
  $roles = array();
  foreach ($result as $role) {
    $roles[$role->rid] = $role;
  }
  return $roles;
}

/**
 * Gets all users with specific role(s).
 *
 * @param $roles
 * @return mixed
 */
function sbac_central_get_users_with_roles($roles) {
  $uids = array();
  $query = 'SELECT DISTINCT(ur.uid) FROM {users_roles} AS ur WHERE ur.rid IN (:rids)';
  $result = db_query($query, array(':rids' => $roles));
  foreach ($result as $row) {
    $uids[] = $row->uid;
  }
  $users = user_load_multiple($uids);
  return $users;
}

/**
 * Check to see if a user has a role
 *
 * @param $roles_arr
 * @param null $account
 * @return bool
 */
function sbac_central_user_has_role($roles_arr, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  $check = array_intersect($roles_arr, array_values($account->roles));
  return empty ($check) ? FALSE : TRUE;
}

/**
 * Gets all users with specific roles and states.
 *
 * @param $roles
 * @param $all_states
 * @return mixed
 */
function sbac_central_get_users_with_roles_and_state($rids, $states) {
  $uids = array();
  $query = 'SELECT ur.uid
            FROM {users_roles} AS ur
            JOIN {field_data_field_state} s
              ON ur.uid = s.entity_id
            WHERE ur.rid IN (:rids)
              AND s.field_state_tid IN (:states)';
  $result = db_query($query, array(':rids' => $rids, ':states' => $states));
  foreach ($result as $row) {
    $uids[$row->uid] = $row->uid;
  }
  $users = user_load_multiple($uids);
  return $users;
}

/**
 * Gets the states that this user has access to.
 *
 * @param $roles
 * @param $all_states
 * @return mixed
 */
function sbac_central_get_user_with_roles_and_state($rids, $states, $uid) {
  $account = array();
  $query = 'SELECT ur.uid
            FROM {users_roles} AS ur
            JOIN {field_data_field_state} s
              ON ur.uid = s.entity_id
            WHERE ur.rid IN (:rids)
              AND s.field_state_tid IN (:states)
              AND ur.uid = :uid';
  $result = db_query($query, array(':rids' => $rids, ':states' => $states, ':uid' => $uid));
  foreach ($result as $row) {
    $account = user_load($row->uid);
  }
  return $account;
}

/**
 * Get the states that this user has access to.
 *
 * @param $states
 * @param $uid
 * @return array|mixed
 */
function sbac_central_get_user_with_states($states, $uid) {
  $query = 'SELECT u.uid
            FROM {users} AS u
            JOIN {field_data_field_state} s
              ON u.uid = s.entity_id
            WHERE
              s.field_state_tid IN (:states)
              AND u.uid = :uid';
  $result = db_query($query, array(':states' => $states, ':uid' => $uid))->fetchObject();
  return $result;
}

/**
 * Implements hook_form_alter().
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function sbac_central_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  if ($form_id == 'taxonomy_form_term') {
    if (!in_array('administrator', $user->roles) || $user->uid != 1) {
      $form['relations']['#access'] = FALSE;
    }
  }

  if ($form_id == 'taxonomy_form_vocabulary') {
    if (!in_array('administrator', $user->roles) || $user->uid != 1) {
      $form['machine_name']['#access'] = FALSE;
    }
  }
}

/**
 * Implements hook_menu_alter().
 *
 * @param $items
 */
function sbac_central_menu_alter(&$items) {
  if (isset($items['admin/structure/taxonomy/add'])) {
    $items['admin/structure/taxonomy/add']['access callback'] = 'sbac_central_access_taxonomy';
  }

  if (isset($items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/fields'])) {
    $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/fields']['access callback'] = 'sbac_central_access_taxonomy';
  }

  if (isset($items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/display'])) {
    $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/display']['access callback'] = 'sbac_central_access_taxonomy';
  }

  if (isset($items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/add'])) {
    $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/add']['access callback'] = 'sbac_central_access_taxonomy';
  }
}

/**
 * Access callback function for menu altered items above.
 *
 * @param $string
 * @param null $account
 * @return bool
 */
function sbac_central_access_taxonomy($string, $account = NULL) {
  if (!user_access('administer site configuration')) {
    return FALSE;
  }
  return user_access($string);
}

/**
 * Implements hook_registry_alter().
 *
 * @param $theme_registry
 */
function sbac_central_theme_registry_alter(&$theme_registry) {
  if (isset($theme_registry['taxonomy_overview_vocabularies'])) {
    $theme_registry['taxonomy_overview_vocabularies']['function'] = 'theme_sbac_central_taxonomy_overview_vocabularies';
  }
}

/**
 * Returns HTML for the vocabulary overview form as a sortable list of vocabularies.
 *
 * @param $variables
 *   An associative array containing:
 *   - form: A render element representing the form.
 *
 * @see taxonomy_overview_vocabularies()
 * @ingroup themeable
 */
function theme_sbac_central_taxonomy_overview_vocabularies($variables) {
  $form = $variables['form'];
  $rows = array();
  foreach (element_children($form) as $key) {
    if (isset($form[$key]['name'])) {
      $vocabulary = & $form[$key];
      $row = array();
      $row[] = drupal_render($vocabulary['name']);
      if (isset($vocabulary['weight'])) {
        $vocabulary['weight']['#attributes']['class'] = array('vocabulary-weight');
        $row[] = drupal_render($vocabulary['weight']);
      }
      $row[] = drupal_render($vocabulary['edit']);
      $row[] = drupal_render($vocabulary['list']);
      if (user_access('administer site configuration')) {
        $row[] = drupal_render($vocabulary['add']);
      }
      else {
        unset($form[$key]['add']);
      }
      $rows[] = array('data' => $row, 'class' => array('draggable'));
    }
  }

  $header = array(t('Vocabulary name'));
  if (isset($form['actions'])) {
    $header[] = t('Weight');
    drupal_add_tabledrag('taxonomy', 'order', 'sibling', 'vocabulary-weight');
  }
  $header[] = array('data' => t('Operations'), 'colspan' => '3');
  return theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'empty' => t('No vocabularies available. <a href="@link">Add vocabulary</a>.', array('@link' => url('admin/structure/taxonomy/add'))),
    'attributes' => array('id' => 'taxonomy')
  )) . drupal_render_children($form);
}

/**
 * Implements hook_block_info().
 */
function sbac_central_block_info() {
  $blocks['feedback-box'] = array(
    'info' => t('Feedback Box'),
    'visibility' => BLOCK_VISIBILITY_LISTED,
    'cache' => DRUPAL_CACHE_PER_USER,
    'weight' => -23,
    'status' => 1,
    'region' => 'feedback',
    'pages' => '*'
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 */
function sbac_central_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'feedback-box':
      $body = variable_get('feedback_block_body', array('value' => '', 'format' => 'full_html'));
      $block['subject'] = t('Feedback Block');
      $block['content'] = $body['value'];
      break;
  }

  return $block;
}

/**
 * Implements hook_block_info_alter().
 *
 * @param $blocks
 * @param $theme
 * @param $code_blocks
 */
function sbac_central_block_info_alter(&$blocks, $theme, $code_blocks) {
  if (isset($blocks['feedback-box']) && $theme == 'SBAC') {
    $blocks['feedback-box']['region'] = 'feedback';
  }
}

/**
 * Implements hook_block_configure().
 */
function sbac_central_block_configure($delta = '') {
  $form = array();

  if ($delta == 'feedback-box') {
    $body = variable_get('feedback_block_body', array('value' => '', 'format' => 'full_html'));

    $form['feedback_block_body'] = array(
      '#type' => 'text_format',
      '#base_type' => 'textarea',
      '#title' => t('Block Body'),
      '#size' => 600,
      '#description' => t('Content shown on the Feedback pop-up block.'),
      '#default_value' => $body['value'],
      '#format' => $body['format'],
    );

    $form['enable_feedback'] = array(
      '#type' => 'checkbox',
      '#title'=> t('Display Feedback overlay to user on login'),
      '#default_value' => variable_get('enable_feedback'),
    );
  }

  return $form;
}
/**
 * Implements hook_block_save().
 */
function sbac_central_block_save($delta = '', $edit = array()) {
  global $user;
  if ($delta == 'feedback-box') {
    variable_set('feedback_block_body', $edit['feedback_block_body']);
    variable_set('enable_feedback', $edit['enable_feedback']);
    if ($edit['enable_feedback'] == 1) {
      db_update('field_data_field_feedback_flag')
        ->fields(array(
          'field_feedback_flag_value' => 0,
        ))
        ->execute();
    }
  }
}

/**
 * Helper.
 *
 * @param $bytes
 * @return string
 */
function sbac_central_format_size_units($bytes) {
  if ($bytes >= 1073741824) {
    $bytes = number_format($bytes / 1073741824, 2) . ' GB';
  }
  elseif ($bytes >= 1048576) {
    $bytes = number_format($bytes / 1048576, 2) . ' MB';
  }
  elseif ($bytes >= 1024) {
    $bytes = number_format($bytes / 1024, 2) . ' KB';
  }
  elseif ($bytes > 1) {
    $bytes = $bytes . ' bytes';
  }
  elseif ($bytes == 1) {
    $bytes = $bytes . ' byte';
  }
  else {
    $bytes = '0 bytes';
  }

  return $bytes;
}

/**
 * Implements hook_user_login().
 */
function sbac_central_user_login(&$edit, $account) {
  if (class_exists('Memcache') && function_exists('dmemcache_get')) {
    // record the login session to memcache
    // we don't use drupals helper functions as they can also be cleared by
    // cc all which will sometimes remove good data that is yet to be recorded.
    $u = user_load($account->uid);
    // create an object to store in the cache
    $wrapper = entity_metadata_wrapper('user', $u);
    if (is_null($wrapper->field_login_count->raw())) {
      $c = 0;
    }
    else {
      $c = $wrapper->field_login_count->raw();
    }
    // create the array
    $login_count['uid'] = $u->uid;
    $login_count['count'] = ++$c;
    $key = 'login_count';
    // check if there is data already in memcache
    $existing_data = dmemcache_get($key);
    // if there is no data set then assign the array
    if ($existing_data === FALSE) {
      $new_data[0] = $login_count;
    }
    else {
      // add the data to the array
      $new_data = $existing_data;
      // set a marker for if a duplicate uid is detected
      $new = 0;
      // TODO check if the user has already registered a login before the last flush to disk
      foreach ($new_data as $k => $v) {
        // if the uid is the same as the current logged in user
        if ($v['uid'] == $u->uid) {
          // then increment the login count
          $new_data[$k]['count'] = $v['count'] + 1;
          // and increment the marker
          $new = 1;
        }
      }
      // if the new var is still 0 then add the new data
      if ($new == 0) {
        $new_data[] = $login_count;
      }
    }
    dmemcache_set($key, $new_data, $exp = 0);
  }
}


/**
 * Implements hook_cron
 */
function sbac_central_cron(){
  if (class_exists('Memcache') && function_exists('dmemcache_get')) {
    // periodically write the login data to the database
    $key = 'login_count';
    // get all the things from the cache
    $items = dmemcache_get($key);

    // check if items[0]==FALSE if so return here (this means no logins to write)
    if($items[0] === FALSE){
      return;
    }
    // if there are items write them to the db
    // nuke the objects from memcache.  Should this be done before or after the loop?
    // i guess we're going to nuke it anyway so maybe should be done before we run
    // the loop so there is a smaller chance of new logins getting nuked
    dmemcache_delete($key);

    // for each item, explode the uid and count
    foreach($items as $i){
      // This is the correct way to do it, but less performant
      // load the user
      // this should already be in static cache as the user logged in at most 59s ago
      $u = user_load($i['uid']);

      // get the wrapper
      $wrapper = entity_metadata_wrapper('user', $u);

      // update the field_login_count field
      $wrapper->field_login_count->set($i['count']);

      // then write them to the user object
      $wrapper->save();
    }
  }
}

/**
 * Get the first and last name of user
 *
 * @param $uid
 * @return mixed
 */
function sbac_central_get_user_first_last_name($uid) {
  $query = db_select('field_data_field_first_name', 'f');
  $query->leftJoin('field_data_field_last_name', 'l', 'f.entity_id = l.entity_id');
  $query->condition('f.entity_id', $uid);
  $query->addExpression('concat(f.field_first_name_value, \' \', l.field_last_name_value)', 'name');
  return $query->execute()->fetchField();
}


/**
 * Migrates old files to new Google CDN.
 */
function sbac_central_migrate_files() {
  $service = NULL;
  $client = NULL;
  $cred = NULL;

  sbac_central_connect_to_google_bucket($service, $client, $cred);
  if ($service && $client && $cred) {
    $nids = sbac_central_get_resource_nids();
    if ($nids) {
      $chunks = array_chunk($nids, 50);
      foreach ($chunks as $chunk) {
        $files_to_upload = array();
        for ($i = 0; $i < 50; $i++) {
          $nid = $chunk[$i];
          // Get all the files for this chunk of nodes.
          $node_files_to_upload = sbac_central_get_node_files_to_upload($nid);
          if ($node_files_to_upload) {
            $files_to_upload[$nid] = $node_files_to_upload;
          }
        }

        // Upload the files.
        if ($files_to_upload) {
          sbac_central_process_files_to_upload($files_to_upload, $client, $service, $cred);
        }
      }
    }
  }
}
/**
 * Connect to the Google Cloud Storage.
 *
 * @param $service
 * @param $client
 */
function sbac_central_connect_to_google_bucket(&$service, &$client, &$cred) {
  try {
    if (libraries_load('google-api-php-client')) {
      $service_account_name = variable_get('oscaddie_gcs_service_account_name');
      $key_file_path = variable_get('oscaddie_gcs_public_key_file_path');

      $client = new Google_Client();
      // Replace this with your application name.
      $client->setApplicationName($service_account_name);
      // Replace this with the service you are using.
      $service = new Google_Service_Storage($client);
      // This file location should point to the private key file.
      $key = file_get_contents($key_file_path);
      $cred = new Google_Auth_AssertionCredentials(
      // Replace this with the email address from the client.
        $service_account_name,
        // Replace this with the scopes you are requesting.
        array('https://www.googleapis.com/auth/devstorage.full_control'),
        $key
      );

      $client->setAssertionCredentials($cred);
      if ($client->getAuth()->isAccessTokenExpired()) {
        $client->getAuth()->refreshTokenWithAssertion($cred);
      }

      $services['client'] = $client;
      $services['service'] = $service;
    }
  }
  catch (Exception $e) {
    watchdog_exception('oscaddie_gcs', $e);
  }
}

/**
 * Get the files to upload from each node.
 *
 * @param $nid
 * @return array
 */
function sbac_central_get_node_files_to_upload($nid) {
  $files_to_upload = array();
  $result = db_query("SELECT * FROM {eck_media} WHERE nid = :nid", array(':nid' => $nid));
  foreach ($result as $document) {
    if ($document->fid) {
      $file = db_query("SELECT * FROM {file_managed} WHERE fid = :fid", array(':fid' => $document->fid))->fetchObject();
      if ($file && strpos($file->uri, 'gs://') === FALSE && strpos($file->uri, 'html5/') !== TRUE) {
        $google_uri = NULL;
        if (strpos($file->uri, 'private://') !== FALSE) {
          $google_uri = str_replace('private://', '', $file->uri);
        }

        if (strpos($file->uri, 'public://') !== FALSE) {
          $google_uri = str_replace('public://', '', $file->uri);
        }

        if ($google_uri) {
          $old_path = drupal_realpath($file->uri);
          if (file_exists($old_path)) {
            $files_to_upload['files'][$file->fid]['fid'] = $file->fid;
          }
        }
      }
    }
  }

  return $files_to_upload;
}

/**
 * Gets an array of nids;
 *
 * @return array
 */
function sbac_central_get_resource_nids() {
  $sql = "SELECT nid FROM {node} WHERE type = 'resource'";
  $result = db_query($sql);
  $nids = array();
  foreach ($result as $row) {
    $nids[] = $row->nid;
  }
  return $nids;
}

/**
 * Process the files to upload and send em to Google Cloud.
 *
 * @param $files_to_upload
 * @param $client
 * @param $service
 */
function sbac_central_process_files_to_upload($files_to_upload, $client, $service, $cred) {
  $bucket = variable_get('google_cdn_bucket_name');
  $folder = variable_get('google_cdn_folder');
  foreach ($files_to_upload as $nid => $files) {
    foreach ($files as $file_info) {
      foreach ($file_info as $fid => $file) {
        try {
          $file = db_query("SELECT * FROM {file_managed} WHERE fid = :fid", array(':fid' => $fid))->fetchObject();
          if ($file) {
            $old_path = drupal_realpath($file->uri);
            if ($client->getAuth()->isAccessTokenExpired()) {
              $client->getAuth()->refreshTokenWithAssertion($cred);
            }
            $chunk_size_bytes = 1 * 1024 * 1024;
            $media = new Google_MediaFileUpload(file_get_mimetype($file->uri), NULL, true, $chunk_size_bytes);
            $media->setFileSize(filesize($old_path));
            $postbody = array(
              'mimeType' => file_get_mimetype($file->uri),
              'data' => NULL,
              'mediaUpload' => $media,
            );
            $google_uri = "resources/" . floor($nid/32000) . "/" . $nid . '/' . $file->filename;

            $gso = new Google_StorageObject();
            $gso->setName($folder . '/' . $google_uri);
            $response = $service->objects->insert($bucket, $gso, $postbody);
            if ($response) {
              // Now upload the file in chunks.
              $upload_result = false;
              $handle = fopen($old_path, "rb");
              while (!$upload_result && !feof($handle)) {
                $chunk = fread($handle, $chunk_size_bytes);
                $upload_result = $media->nextChunk($response, $chunk);
              }
              fclose($handle);

              // file uploaded successfully, set the new URI.
              if ($upload_result) {
                $new_uri = 'gs://' . $google_uri;
                db_query('UPDATE {file_managed} SET uri = :uri WHERE fid = :fid', array(':uri' => $new_uri, ':fid' => $fid));
              }
            }

            unset($media);
            unset($gso);
            unset($response);
            unset($postbody);
            unset($google_uri);
            unset($handle);
          }
        }
        catch (Exception $e) {
          watchdog('google_cdn', $e);
        }
      }
    }
  }
}