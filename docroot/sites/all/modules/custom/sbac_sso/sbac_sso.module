<?php

/**
 * @file.
 * Module to handle all SSO related functionality.
 *
 * Provides:
 *  - Consumes SAML assertions and validates assertion
 *  - Logs user in depending on SAML credentials or creates a new user
 *  - Logs user out, destroying session on Drupal and SSO system
 *  - Handles UI requirement for session extension
 */

if (isset($_ENV['AH_SITE_ENVIRONMENT'])) {
  switch ($_ENV['AH_SITE_ENVIRONMENT']) {
    case 'dev':
    case 'stage2':
    case 'stage3':
    case 'sbac-023-d':
      define('SBAC_SSO_URL', 'https://amp-dev-secure.smarterbalanced.org/auth/SSORedirect/metaAlias/sbac/idp');
      define('SBAC_SSO_PROGRAM_REQUEST_AUTH', 'https://amp-dev-secure.smarterbalanced.org/auth/oauth2/access_token?realm=/sbac');
      define('SBAC_SSO_PROGRAM_OAUTH_API_LIST', 'https://pm-sso.opentestsystem.org:8443/rest/tenants');
      define('SBAC_SSO_PROGRAM_OAUTH_API', 'https://pm-sso.opentestsystem.org:8443/rest/tenantchain');
      define('SBAC_SSO_DESTROY_SESSION_URL', 'https://amp-dev-secure.smarterbalanced.org/auth/UI/Logout');
      define('SBAC_SSO_LOGOUT_REDIRECT_URL', 'https://amp-dev-secure.smarterbalanced.org/auth/IDPSloRedirect/metaAlias/sbac/idp');
      break;
    case 'test':
    case 'stage':
    case 'loadtest':
    case 'sbac-023-train':
      define('SBAC_SSO_URL', 'https://sso-uat.smarterbalanced.org/auth/SSORedirect/metaAlias/sbac/idp');
      define('SBAC_SSO_PROGRAM_REQUEST_AUTH', 'https://amp-dev-secure.smarterbalanced.org/auth/oauth2/access_token?realm=/sbac');
      define('SBAC_SSO_PROGRAM_OAUTH_API_LIST', 'https://pm-sso.opentestsystem.org:8443/rest/tenants');
      define('SBAC_SSO_PROGRAM_OAUTH_API', 'https://pm-sso.opentestsystem.org:8443/rest/tenantchain');
      define('SBAC_SSO_DESTROY_SESSION_URL', 'https://sso-uat.smarterbalanced.org/auth/UI/Logout');
      define('SBAC_SSO_LOGOUT_REDIRECT_URL', 'https://sso-uat.smarterbalanced.org/auth/IDPSloRedirect/metaAlias/sbac/idp');
      break;
    case 'prod':
      define('SBAC_SSO_URL', 'https://sso.smarterbalanced.org/auth/SSORedirect/metaAlias/sbac/idp');
      define('SBAC_SSO_PROGRAM_REQUEST_AUTH', 'https://amp-dev-secure.smarterbalanced.org/auth/oauth2/access_token?realm=/sbac');
      define('SBAC_SSO_PROGRAM_OAUTH_API_LIST', 'https://pm-sso.opentestsystem.org:8443/rest/tenants');
      define('SBAC_SSO_PROGRAM_OAUTH_API', 'https://pm-sso.opentestsystem.org:8443/rest/tenantchain');
      define('SBAC_SSO_PROGRAM_API', 'https://pm.smarterbalanced.org/rest/tenantchain');
      define('SBAC_SSO_PROGRAM_API_LIST', 'https://pm.smarterbalanced.org/rest/tenants');
      define('SBAC_SSO_DESTROY_SESSION_URL', 'https://sso.smarterbalanced.org/auth/UI/Logout');
      define('SBAC_SSO_LOGOUT_REDIRECT_URL', 'https://sso.smarterbalanced.org/auth/IDPSloRedirect/metaAlias/sbac/idp');
      break;
  }
}
else {
  define('SBAC_SSO_URL', 'https://sso-uat.smarterbalanced.org/auth/SSORedirect/metaAlias/sbac/idp');
  define('SBAC_SSO_PROGRAM_REQUEST_AUTH', 'https://amp-dev-secure.smarterbalanced.org/auth/oauth2/access_token?realm=/sbac');
  define('SBAC_SSO_PROGRAM_OAUTH_API_LIST', 'https://pm-sso.opentestsystem.org:8443/rest/tenants');
  define('SBAC_SSO_PROGRAM_OAUTH_API', 'https://pm-sso.opentestsystem.org:8443/rest/tenantchain');
  define('SBAC_SSO_DESTROY_SESSION_URL', 'https://sso-uat.smarterbalanced.org/auth/UI/Logout');
  define('SBAC_SSO_LOGOUT_REDIRECT_URL', 'https://sso-uat.smarterbalanced.org/auth/IDPSloRedirect/metaAlias/sbac/idp');
}

/**
 * Implements hook_menu().
 *
 * @return array
 */
function sbac_sso_menu() {
  $items = array();

  $items['sbac-sso-consume'] = array(
    'title' => 'SBAC Consume',
    'page callback' => 'sbac_sso_consume',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['sbac-sso-logout'] = array(
    'title' => 'SBAC Logout',
    'page callback' => 'sbac_sso_logout',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['sbac-sso-error'] = array(
    'title' => 'SBAC Error',
    'page callback' => 'sbac_sso_error',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['sbac-sso/%ctools_js/session-expire'] = array(
    'title' => 'Session Expire',
    'page callback' => 'sbac_sso_session_expire_modal',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
  );

  $items['sbac-sso-cron'] = array(
    'title' => 'SBAC Cron',
    'page callback' => 'sbac_sso_test_cron',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['sbac-sso/conflicting-profile'] = array(
    'title' => 'Please confirm your profile information',
    'page callback' => 'sbac_sso_conflicting_profile',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_boot().
 */
function sbac_sso_boot() {
  // If the conflicting profile variable is set, go to that page, since it
  // gets cleared on submit of that form.
  if (isset($_SESSION['sbac-sso']['conflicting_profile']) && $_SESSION['sbac-sso']['conflicting_profile'] == TRUE && arg(0) != 'sbac-sso' && arg(1) != 'conflicting-profile') {
      global $base_url;
      $path = $base_url . '/sbac-sso/conflicting-profile';
      header('Location: ' . $path, TRUE, 302);
      drupal_exit($path);
  }
}

/**
 * Implements hook_menu_alter().
 *
 * @param $items
 */
function sbac_sso_menu_alter(&$items) {
  // If you wish to disable this module from overriding Drupal login / logout.
//  if (!isset($_ENV['AH_SITE_ENVIRONMENT']) || $_ENV['AH_SITE_ENVIRONMENT'] != 'loadtest') {
//    if (isset($items['user'])) {
//      $items['user']['page callback'] = 'sbac_sso_consume';
//      $items['user']['module'] = 'sbac_sso';
//      $items['user']['file'] = NULL;
//    }
//    if (isset($items['user/logout'])) {
//      $items['user/logout']['page callback'] = 'sbac_sso_logout';
//      $items['user/logout']['module'] = 'sbac_sso';
//      $items['user/logout']['file'] = NULL;
//    }
//  }
}

/**
 * Session expire modal.
 *
 * @param bool $js
 */
function sbac_sso_session_expire_modal($js = FALSE) {
  if ($js) {
    ctools_include('ajax');
    ctools_include('modal');
    ctools_add_js('ajax-responder');
    ctools_modal_add_js();

    $title = 'Your session is about to end';
    $form_state = array(
      'title' => $title,
      'ajax' => TRUE,
    );

    $output = ctools_modal_form_wrapper('sbac_sso_session_expire_form', $form_state);
    if (!empty($form_state['executed'])) {
      $output = array();
      $output[] = ctools_modal_command_dismiss();
      if ($form_state['triggering_element']['#value'] == 'OK') {
        sbac_sso_session_regenerate();
      }
      else {
        global $base_url;
        global $user;
        $logout_assertion = sbac_sso_logout_assertion();
        watchdog('user', 'Session closed for %name.', array('%name' => $user->name));
        module_invoke_all('user_logout', $user);
        session_destroy();

        $logout_url = SBAC_SSO_LOGOUT_REDIRECT_URL . '?SAMLRequest=' . urlencode(base64_encode(gzdeflate(stripslashes($logout_assertion)))) . '&RelayState=' . $base_url . '/user';
        $output[] = ctools_ajax_command_redirect($logout_url);
      }
    }
    print ajax_render($output);
    exit();
  }
}

/**
 * Session expire form.
 *
 * @param $form
 * @param $form_state
 * @return array
 */
function sbac_sso_session_expire_form($form, &$form_state) {
  $form = array();

  $form['submit_description'] = array(
    '#markup' => "<p>Select OK to
        extend your session. Pressing Cancel or failing to respond in the next
        two minutes will require site reauthentication.</p>"
  );

  $form['continue'] = array(
    '#type' => 'submit',
    '#value' => 'OK',
    '#attributes' => array('class' => array('button', 'blue'))
  );

  $form['cancel'] = array(
    '#type' => 'submit',
    '#value' => 'Cancel',
    '#attributes' => array('class' => array('button', 'gray', 'cancel'))
  );

  $form['button_suffix'] = array(
    '#suffix' => '</div>',
  );

  return $form;
}

/**
 * Called when an anonymous user becomes authenticated or vice-versa.
 *
 * Pretty much a carbon copy of drupal's own session_regenerate. Except,
 * I removed the session_id regeneration so that if a session is extended,
 * the id stays the same.
 * Added the updating of timestamp to work with Drupal's garbage collector.
 * Drupal would remove an entry from the [sessions] table causing users to lose
 * their progress when working with forms.
 *
 * @ingroup php_wrappers
 */
function sbac_sso_session_regenerate() {
  global $user, $is_https;
  // Nothing to do if we are not allowed to change the session.
  if (!drupal_save_session()) {
    return;
  }

  if ($is_https && variable_get('https', FALSE)) {
    $insecure_session_name = substr(session_name(), 1);
    if (!isset($GLOBALS['lazy_session']) && isset($_COOKIE[$insecure_session_name])) {
      $old_insecure_session_id = $_COOKIE[$insecure_session_name];
    }
    $params = session_get_cookie_params();
    $session_id = drupal_random_key();
    // If a session cookie lifetime is set, the session will expire
    // $params['lifetime'] seconds from the current request. If it is not set,
    // it will expire when the browser is closed.
    $expire = $params['lifetime'] ? REQUEST_TIME + $params['lifetime'] : 0;
    setcookie($insecure_session_name, $session_id, $expire, $params['path'], $params['domain'], FALSE, $params['httponly']);
    $_COOKIE[$insecure_session_name] = $session_id;
  }

  if (drupal_session_started()) {
    $old_session_id = session_id();
  }
  //  session_id(drupal_random_key());

  if (isset($old_session_id)) {
    $params = session_get_cookie_params();
    $expire = $params['lifetime'] ? REQUEST_TIME + $params['lifetime'] : 0;
    setcookie(session_name(), $old_session_id, $expire, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
    $fields = array(
      'sid' => $old_session_id,
      'timestamp' => time(),
    );

    if ($is_https) {
      $fields['ssid'] = $old_session_id;
      // If the "secure pages" setting is enabled, use the newly-created
      // insecure session identifier as the regenerated sid.
      if (variable_get('https', FALSE)) {
        $fields['sid'] = $old_session_id;
      }
    }
    db_update('sessions')
      ->fields($fields)
      ->condition($is_https ? 'ssid' : 'sid', $old_session_id)
      ->execute();
  }
  elseif (isset($old_insecure_session_id)) {
    // If logging in to the secure site, and there was no active session on the
    // secure site but a session was active on the insecure site, update the
    // insecure session with the new session identifiers.
    db_update('sessions')
      ->fields(array('sid' => $session_id, 'ssid' => session_id()))
      ->condition('sid', $old_insecure_session_id)
      ->execute();
  }
  else {
    // Start the session when it doesn't exist yet.
    // Preserve the logged in user, as it will be reset to anonymous
    // by _drupal_session_read.
    $account = $user;
    drupal_session_start();
    $user = $account;
  }
  date_default_timezone_set(drupal_get_user_timezone());
}

/**
 * Implements hook_preprocess_page().
 *
 * @param $vars
 */
function sbac_sso_preprocess_page(&$vars) {
  // Regenerate the user session per page.
  if (user_is_logged_in() && strpos($_GET['q'], 'ajax') === FALSE) {
    sbac_sso_session_regenerate();
  }

  // If the user is being presented with the conflicting profile screen
  // remove the menu bar, user menu etc.
  $vars['conflicting_profile'] = FALSE;
  if (isset($_SESSION['sbac-sso']['conflicting_profile']) && $_SESSION['sbac-sso']['conflicting_profile'] == TRUE) {
    $vars['conflicting_profile'] = TRUE;
    $vars['home_url'] = '#';
  }

  // If the page requested is a moderation page, do not include this timer. As there
  // is already a timer for the moderation functionality. Look at sbac_flag module.
  if (isset($_GET['flag']) && ($_GET['flag'] == 'resolve-resource-flags' || $_GET['flag'] == 'resolve-resource-review-flags')) {
    return;
  }
  elseif (user_is_logged_in() && arg(0) != 'admin') {
    ctools_include('modal');
    ctools_include('ajax');
    ctools_add_js('ajax-responder');
    ctools_modal_add_js();
    drupal_add_library('system', 'drupal.ajax');
    drupal_add_js(drupal_get_path('module', 'sbac_sso') . '/js/sbac_sso.ctools.js');
    drupal_add_js(drupal_get_path('module', 'sbac_sso') . '/js/sbac_sso.js');
    $session_button = l(t('Session Expire (modal)'), 'sbac-sso/nojs/session-expire', array(
      'attributes' => array(
        'class' => 'ctools-use-modal button red use-ajax ctools-modal-sbac-sso-session-expire small',
        'id' => 'sbac-sso-session-expire'
      ),
    ));
    $js_settings = array('sbac-sso-session-expire' => array('modalSize' => array('type' => 'fixed', 'width' => 600, 'height' => 260), 'modalTheme' => 'CtoolSbacSSOExpire'));
    drupal_add_js($js_settings, 'setting');
    $vars['session_expire'] = $session_button;
    $session_info = session_get_cookie_params();
    drupal_add_js(array('sbac_session_lifetime' => $session_info['lifetime']), 'setting');
  }
}

/**
 * The SSO Error page.
 *
 * @return mixed
 */
function sbac_sso_error() {
  (!isset($_GET['code']) ? $code = NULL : $code = $_GET['code']);
  $possible_titles = array(
    t('Access to the Digital Library is Denied'),
    t('We are unable to create your Digital Library profile.'),
    t('There appears to be a problem.'),
  );
  $possible_error_codes = array(
    100 => t("Error code 100"),
    101 => t("Error code 101"),
    102 => t("Error code 102"),
    103 => t("Error code 103"),
    104 => t("Error code 104"),
    105 => t("Error code 105"),
    200 => t("Error code 200"),
  );
  $possible_messages = array(
    t("You don't have permission to view this with your credentials. Please contact your local district administrator for assistance."),
    t("There is missing or invalid information that is required to create your Digital Library profile. Please contact your local district administrator for assistance."),
    t("Please contact your local district administrator for assistance."),
  );

  switch ($code) {
    case 102:
    case 200:
      $title = 0;
      $message = 0;
      break;
    case 100:
    case 101:
    case 103:
    case 104:
    case 105:
      $title = 1;
      $message = 1;
      break;
    default:
      $title = 2;
      $message = 2;
      break;
  }

  drupal_set_title($possible_titles[$title]);
  $output = '<p>' .$possible_messages[$message]. '</p>';
  $output .= '<span class="error-code">' . $possible_error_codes[$code] . '</span>';
  return $output;
}

/**
 * Implements hook_form_alter().
 *
 * Used to hide the login form on this page.
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function sbac_sso_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'user_login_block') {
    if ($_GET['q'] == 'sbac-sso-error') {
      $form['#access'] = FALSE;
    }
  }
}

/**
 * Consumes the SAML Assertion.
 */
function sbac_sso_consume() {
  $is_valid = FALSE;
  $saml_token = NULL;
  if (isset($_POST['SAMLResponse'])) {
    $saml_token = base64_decode($_POST['SAMLResponse']);
    $is_valid = sbac_sso_validate_saml_assertion($saml_token);
  }
  else {
    // Destroy the current session, and reset $user to the anonymous user.
    if (user_is_logged_in()) {
      global $user;
      watchdog('user', 'Session closed for %name.', array('%name' => $user->name));
      module_invoke_all('user_logout', $user);
      session_destroy();
    }

    global $base_url;
    $original_access_url = $base_url;
    if (isset($_GET['destination'])) {
      $original_access_url = $base_url . '/' . $_GET['destination'];
    }
    // Record original access URL (URL Encoded) to the SAML request in the relayState variable
    // Direct user to SSO with relaystate pointing to SAML Assertion receiving endpoint.
    $saml_assertion = sbac_sso_saml_assertion();
    $url = SBAC_SSO_URL . '?SAMLRequest=' . urlencode(base64_encode(gzdeflate($saml_assertion))) . '&RelayState=' . urlencode($original_access_url);
    header('Location: ' . $url, TRUE, 302);
    drupal_exit($url);
  }

  if ($is_valid) {
    // validate SAML.
    sbac_sso_validate_saml_response($saml_token);
  }
  else {
    drupal_goto('sbac-sso-error', array('query' => array('code' => 100)));
  }
}

/**
 * Validate the SAML assertion.
 *
 * @param $saml_token
 * @return bool
 */
function sbac_sso_validate_saml_assertion($saml_token) {
  require_once(drupal_get_path('module', 'sbac_sso') . '/xmlseclibs/xmlseclibs.php');
  $doc = new DOMDocument();
  $doc->loadXML($saml_token);
  $objXMLSecDSig = new XMLSecurityDSig();
  $objDSig = $objXMLSecDSig->locateSignature($doc);
  if (!$objDSig) {
    watchdog('sbac_sso', 'Cannot locate Signature Node');
    return FALSE;
  }
  $objXMLSecDSig->canonicalizeSignedInfo();
  $objXMLSecDSig->idKeys = array('ID');
  $objXMLSecDSig->idNS = array('wsu' => 'http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd');
  $retVal = $objXMLSecDSig->validateReference();
  if (!$retVal) {
    watchdog('sbac_sso', 'Reference Validation Failed');
    return FALSE;
  }
  $objKey = $objXMLSecDSig->locateKey();
  if (!$objKey) {
    watchdog('sbac_sso', 'We have no idea about the key');
    return FALSE;
  }
  $key = NULL;
  $objKeyInfo = XMLSecEnc::staticLocateKeyInfo($objKey, $objDSig);
  if (!$objKeyInfo->key && empty($key)) {
    watchdog('sbac_sso', 'Key could not be found.');
    return FALSE;
  }
  if ($objXMLSecDSig->verify($objKey)) {
    return TRUE;
  }
  else {
    watchdog('sbac_sso', 'Key could not be verified.');
    return FALSE;
  }
}

/**
 * Implements hook_user_login().
 *
 * @param $edit
 * @param $account
 */
function sbac_sso_user_login(&$edit, $account) {
  if (isset($_SESSION['sbac-sso'])) {
    $sbac_sso_vars = $_SESSION['sbac-sso'];
    if (isset($sbac_sso_vars['multiple']) && $sbac_sso_vars['multiple'] == TRUE) {
      // If the user does not have the hash field set and has multiple chains, present form
      if (empty($account->field_sso_tenancy_hash)) {
        $_SESSION['sbac-sso']['conflicting_profile'] = TRUE;
        drupal_goto('sbac-sso/conflicting-profile');
      }
      // If the user has the hash field set but is different from stored value, present form
      if ($account->field_sso_tenancy_hash['und'][0]['value'] != $sbac_sso_vars['hash']) {
        $_SESSION['sbac-sso']['conflicting_profile'] = TRUE;
        drupal_goto('sbac-sso/conflicting-profile');
      }
    }
  }
}

/**
 * Custom logout callback.
 */
function sbac_sso_logout() {
  if (user_is_logged_in()) {
    global $base_url;
    global $user;
    unset($_GET['q']);
    $logout_assertion = sbac_sso_logout_assertion();
    // Destroy the current session, and reset $user to the anonymous user.
    watchdog('user', 'Session closed for %name.', array('%name' => $user->name));
    module_invoke_all('user_logout', $user);
    session_destroy();
    $logout_url = SBAC_SSO_LOGOUT_REDIRECT_URL . '?SAMLRequest=' . urlencode(base64_encode(gzdeflate(stripslashes($logout_assertion)))) . '&RelayState=' . $base_url . '/user';
    drupal_goto($logout_url);
  }
  else {
    drupal_goto('user');
  }
}

/**
 * Validates the SAML response.
 *
 * Parses the SAML response and grabs all the values. Then
 * parses the tenancy chain and validates the tenants against
 * the program management service.
 *
 * @param string $saml_token
 *   The SAML assertion.
 */
function sbac_sso_validate_saml_response($saml_token) {
  $response = sbac_sso_parse_saml_assertion($saml_token);
  // If SAML assertion does not match expected definition or signature:
  if (!$response || !isset($response['session_index'])) {
    // If you do not find a matching tenancy chain, kick the user to an error page
    // with Smarter Balanced Contact information and a custom error code
    // ERROR CODE 100: Problem processing Assertion
    drupal_goto('sbac-sso-error', array('query' => array('code' => 100)));
  }
  // If there are no raw tenancy chains or if there are no tenancy chains with 'DL_EndUser' as the client
  if (!isset($response['sbac_tenancy_chains_raw']) || !isset($response['sbac_tenancy_chains_unvalidated'])) {
    // ERROR CODE 101: Assertion did not contain tenancy chain with DL_EndUser role
    drupal_goto('sbac-sso-error', array('query' => array('code' => 101)));
  }
  // program manager api call.
  $api_response = sbac_sso_program_management_api_request($response);
  if (!$api_response) {
    // Kick the user to an error page with Smarter Balanced Contact information
    // and a custom error code ( do not include the details pertaining to what
    // the error code is connected to, just the ERROR CODE and NUMBER :
    // ERROR CODE 102: Program Management returned INVALID ACCESS
    drupal_goto('sbac-sso-error', array('query' => array('code' => 102)));
  }
  // Determine if the user has multiple tenancy chains
  $multiple = sbac_sso_determine_multiple_tenancy_chains($response);
  // Determine if user is new or existing
  $user = sbac_sso_determine_user($response, $multiple);
  // If multiple tenancy chains and the tenancy chain hash does not match
  // one on user proflie, display conflicting profile screen
  // or if new user and multiple tenancy chains
  $hash = sbac_sso_generate_tenancy_chain_hash($response);
  if ($user) {
    sbac_sso_log_user_in($user, $multiple, $response, $hash);
  }
  else {
    // If all else failed, send them to the default error page.
    drupal_goto('sbac-sso-error');
  }
}

/**
 * Parse the SAML assertion.
 *
 * @param $saml_token
 * @return array
 */
function sbac_sso_parse_saml_assertion($saml_token) {
  $response = array();
  $value = NULL;
  $saml_strings = explode("\n", $saml_token);
  if (strpos($saml_token, '<ds:X509Certificate xmlns:ds="http://www.w3.org/2000/09/xmldsig#">') !== FALSE) {
    $certificate = '<ds:X509Certificate xmlns:ds="http://www.w3.org/2000/09/xmldsig#">';
    $pos = strpos($saml_token, $certificate);
    $half_value = substr($saml_token, $pos + strlen($certificate));
    $last_pos = strpos($half_value, '</ds:X509Certificate>');
    $value = trim(substr($half_value, 0, $last_pos));
    if ($value) {
      $response['x509_certificate'] = $value;
    }
  }

  if (strpos($saml_token, '<ds:SignatureValue xmlns:ds="http://www.w3.org/2000/09/xmldsig#">') !== FALSE) {
    $certificate = '<ds:SignatureValue xmlns:ds="http://www.w3.org/2000/09/xmldsig#">';
    $pos = strpos($saml_token, $certificate);
    $half_value = substr($saml_token, $pos + strlen($certificate));
    $last_pos = strpos($half_value, '</ds:SignatureValue>');
    $value = trim(substr($half_value, 0, $last_pos));
    if ($value) {
      $response['signature_value'] = $value;
    }
  }

  foreach ($saml_strings as $row) {
    if (strpos($row, 'SessionIndex') !== FALSE) {
      sbac_sso_parse_saml_assertion_row($response, $row, 'SessionIndex="', '">', 'session_index');
    }
    if (strpos($row, '<ds:DigestValue xmlns:ds="http://www.w3.org/2000/09/xmldsig#">') !== FALSE) {
      sbac_sso_parse_saml_assertion_row($response, $row, '<ds:DigestValue xmlns:ds="http://www.w3.org/2000/09/xmldsig#">', '</ds:DigestValue>', 'digest_value');
    }
    if (strpos($row, '<saml:Attribute Name="sbacUUID">') !== FALSE) {
      $attribute = '<saml:Attribute Name="sbacUUID"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'sbac_uuid');
    }
    if (strpos($row, '<saml:Attribute Name="sn">') !== FALSE) {
      $attribute = '<saml:Attribute Name="sn"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'sn');
    }
    if (strpos($row, '<saml:Attribute Name="entryuuid">') !== FALSE) {
      $attribute = '<saml:Attribute Name="entryuuid"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'entry_uuid');
    }
    if (strpos($row, '<saml:Attribute Name="mail">') !== FALSE) {
      $attribute = '<saml:Attribute Name="mail"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'email');
    }
    if (strpos($row, '<saml:Attribute Name="cn">') !== FALSE) {
      $attribute = '<saml:Attribute Name="cn"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'cn');
    }
    if (strpos($row, '<saml:Attribute Name="sbacTenancyChain">') !== FALSE) {
      $attribute = '<saml:Attribute Name="sbacTenancyChain">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:Attribute>', 'sbac_tenancy_chains_raw', TRUE);
    }
    if (strpos($row, '<saml:Attribute Name="givenName">') !== FALSE) {
      $attribute = '<saml:Attribute Name="givenName"><saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
      sbac_sso_parse_saml_assertion_row($response, $row, $attribute, '</saml:AttributeValue', 'given_name');
    }
  }
  return $response;
}

/**
 * Parse the SAML Assertion Row.
 *
 * @param $response
 * @param $row
 * @param $attribute_start
 * @param $attribute_end
 * @param $response_name
 *
 * @param bool $tenancy_chain
 */
function sbac_sso_parse_saml_assertion_row(&$response, &$row, $attribute_start, $attribute_end, $response_name, $tenancy_chain = FALSE) {
  $pos = strpos($row, $attribute_start);
  $half_value = substr($row, $pos + strlen($attribute_start));
  $last_pos = strpos($half_value, $attribute_end);
  $value = substr($half_value, 0, $last_pos);
  if ($value) {
    if ($tenancy_chain) {
      $tenancy_chains = sbac_sso_parse_tenancy_chain($value, $attribute_start, $attribute_end);
      if ($tenancy_chains) {
        $response[$response_name] = $tenancy_chains;
        // Create clean tenancy chains with only DL_EndUser client.
        sbac_sso_create_clean_tenancy_chains($tenancy_chains, $response);
      }
    }
    else {
      $response[$response_name] = $value;
      $value = NULL;
    }
  }
}

/**
 * Parse the tenancy chain(s).
 *
 * @param $value
 * @param $attribute_start
 * @param $attribute_end
 *
 * @return array
 */
function sbac_sso_parse_tenancy_chain(&$value, &$attribute_start, &$attribute_end) {
  $tenancy_chains = array();
  $tenancy_length = strlen($value);
  $attribute_value_start = '<saml:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string">';
  $attribute_value_end = '</saml:AttributeValue>';
  while ($tenancy_length > 0) {
    $pos = strpos($value, $attribute_value_start);
    $half_value = substr($value, $pos + strlen($attribute_value_start));
    $last_pos = strpos($half_value, $attribute_value_end);
    $value = substr($half_value, 0, $last_pos);
    $length = strlen($value);
    // Remove the beginning and end '|' characters.
    if ($value[$length -1] == '|') {
      $value = substr($value, 0, $length -1);
    }
    if ($value[0] == '|') {
      $value = substr($value, 1);
    }
    $tenancy_chains[] = $value;
    // Remove the string we just stored.
    $value = substr_replace($half_value, '', 0, $last_pos + strlen($attribute_value_end));
    $tenancy_length = strlen($value);
  }
  return $tenancy_chains;
}

/**
 * Determine if there are duplicate states in this chain.
 *
 * If duplicate states, merge them into a single value
 * and keep the most complete array. Only keep tenancy
 * chains with DL_EndUser as the client.
 *
 * @param $tenancy_chains
 * @param $response
 */
function sbac_sso_create_clean_tenancy_chains(&$tenancy_chains, &$response) {
  foreach ($tenancy_chains as $chain) {
    $parsed_chain = sbac_sso_create_user_attributes($chain);
    // Only keep tenancy chains with DL_EndUser and a state attribute.
    if (isset($parsed_chain['name']) && $parsed_chain['name'] == 'DL_EndUser' && isset($parsed_chain['state_id']) && $parsed_chain['state_id'] != NULL) {
      $response['sbac_tenancy_chains_unvalidated'][$parsed_chain['state_id']][] = $parsed_chain;
    }
  }

  if ($response['sbac_tenancy_chains_unvalidated']) {
    $keep_chain = array();
    foreach ($response['sbac_tenancy_chains_unvalidated'] as $state_id => $unvalidated_tenancy_chains) {
      foreach ($unvalidated_tenancy_chains as $key => $chain) {
        // Keep the chain with the highest weight, if the same weight, just choose the first one.
        // Meaning, if chain includes state/district/institution keep that one, if the
        // chain includes state/district and state/institution, keep the first one since the
        // weight (number of items) is the same.
        if (count($chain) > count($keep_chain[$state_id]) || !isset($keep_chain[$state_id])) {
          $keep_chain[$state_id] = $chain;
        }
      }
    }
    $response['sbac_tenancy_chains_unvalidated'] = $keep_chain;
  }
}

/**
 * Create the user attributes array.
 *
 * @param $chain
 *
 * @return array
 */
function sbac_sso_create_user_attributes($chain) {
  $user_attributes = array();
  $attributes = explode('|', $chain);
  if ($attributes) {
    $user_fields = array(
      'role_id' => 'role_id',
      'name' => 'name',
      'level' => 'level',
      'client_id' => 'client_id',
      'client' => 'client',
      'group_of_state_ids' => 'group_of_state_ids',
      'group_of_states' => 'group_of_states',
      'state_id' => 'state_id',
      'state' => 'state',
      'group_of_district_ids' => 'group_of_district_ids',
      'group_of_districts' => 'group_of_districts',
      'district_id' => 'district_id',
      'district' => 'district',
      'group_of_institution_ids' => 'group_of_institution_ids',
      'group_of_institutions' => 'group_of_institutions',
      'institution_id' => 'institution_id',
      'institution' => 'institution',
    );

    if (count($user_fields) == count($attributes)) {
      $user_attributes = array_combine($user_fields, $attributes);
    }

    foreach ($user_attributes as $key => $value) {
      if ($value == '' || $value == NULL) {
        unset($user_attributes[$key]);
      }
      if ($key == 'institution' || $key == 'district') {
        $user_attributes[$key] = ucwords(strtolower(htmlspecialchars_decode(str_replace("&amp;apos;", "'", $value))));
      }
    }
  }
  return $user_attributes;
}

/**
 * Get the response from Program Management API.
 *
 * Before presenting tenancy chains, please cross check those that have the DL_EndUser role
 * against the cached Program Management tenant list and ones that don’t match against the PM
 * API endpoint so as not to present options that may be on file but don’t refer to currently
 * valid tenants.
 *
 * @param $response
 *
 * @return array
 */
function sbac_sso_program_management_api_request(&$response) {
  //  https://pm-dev.opentestsystem.org:8443/programmanagement.rest/tenantchain?STATE_GROUP=SBAC&DISTRICT=Foo
  //  As you can see in the above request, I’m sending it a STATE_GROUP and DISTRICT. A full tenancy chain will contain more than that so you’d send it:
  //  "CLIENT", "STATE_GROUP", "STATE", "DISTRICT_GROUP", "DISTRICT", "INSTITUTION_GROUP", "INSTITUTION"
  //  All of which are in the tenancy chains received in an SSO Assertion.
  $query_string = '';
  $valid_tenancy_chain_indexes = array('client', 'group_of_states', 'state_id', 'group_of_districts', 'district', 'group_of_institutions', 'institution');
  foreach ($response['sbac_tenancy_chains_unvalidated'] as $state => $tenancy_chain) {
    foreach ($tenancy_chain as $index => $attribute) {
      if (in_array($index, $valid_tenancy_chain_indexes) && $attribute) {
        switch ($index) {
          case 'group_of_states':
            $query_string[$state]['STATE_GROUP'] = $attribute;
            break;
          case 'state_id':
            $query_string[$state]['STATE'] = $attribute;
            break;
          case 'group_of_districts':
            $query_string[$state]['DISTRICT_GROUP'] = $attribute;
            break;
          case 'district_id':
            $query_string[$state]['DISTRICT'] = $attribute;
            break;
          case 'group_of_institutions':
            $query_string[$state]['INSTITUTION_GROUP'] = $attribute;
            break;
          case 'institution_id':
            $query_string[$state]['INSTITUTION'] = $attribute;
            break;
        }
        $query_string[$state]['cache']['cache_valid'] = NULL;
        $query_string[$state]['cache']['cache_result'] = NULL;
      }
    }
  }

  // Check the cache table.
  $cached_results = variable_get('sbac_sso_pm_cached_results');
  if ($cached_results) {
    foreach ($query_string as $state => $query_params) {
      foreach ($query_params as $type => $state_id) {
        if ($type != 'cache') {
          foreach ($cached_results[$type] as $cached_id => $cached_result) {
            if ($cached_result['type'] == 'STATE' && $cached_result['name'] == $query_params['STATE']) {
              $json['tenants'][0] = $cached_result;
              $in_good_standing = sbac_sso_parse_program_api_response($json, TRUE);
              if ($in_good_standing) {
                $query_string[$state]['cache']['cache_valid'] = TRUE;
                $query_string[$state]['cache']['cache_result'] = $cached_result;
              }
              else {
                $query_string[$state]['cache']['cache_valid'] = FALSE;
                $query_string[$state]['cache']['cache_result'] = FALSE;
              }
              break;
            }
          }
        }
      }
    }
  }

  $api_response = sbac_sso_get_program_management_response($response, $query_string);
  return $api_response;
}

/**
 * Get the program management response.
 *
 * @param $response
 * @param $query_string
 * @return array
 */
function sbac_sso_get_program_management_response(&$response, $query_string) {
  $api_response = array();
  // Get the OAuth token to make calls to Program Management.
  $access_token = sbac_sso_get_program_management_oauth_access_token();
  if ($access_token) {
    // Loop around all state query string and get the PM results for each one.
    foreach ($query_string as $state => $query) {
      $cache = NULL;
      if (isset($query['cache'])) {
        $cache = $query['cache'];
        unset($query['cache']);
      }
      if ($cache == NULL || ($cache['cache_valid'] == FALSE || $cache['cache_valid'] == NULL)) {
        $data = http_build_query($query);
        $post = SBAC_SSO_PROGRAM_OAUTH_API . '?' . $data;
        $curl = curl_init();
        curl_setopt($curl, CURLOPT_URL, $post);
        curl_setopt($curl, CURLOPT_HTTPHEADER, array(
          'Authorization: Bearer ' . $access_token,
        ));
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);
        curl_setopt($curl, CURLOPT_SSLVERSION,3);
        $result = curl_exec($curl);
        $http_status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        if ($result && $http_status == 200) {
          $json = drupal_json_decode($result);
          if (isset($json['tenants'])) {
            $response['pm_api_results'][$state]['tenants'] = $json['tenants'];
          }
        }
      }
      else {
        $api_response[$state] = $cache['cache_result'];
        $response['sbac_tenancy_chains_validated'][$state] = $response['sbac_tenancy_chains_unvalidated'][$state];
      }
    }
  }

  if (isset($response['pm_api_results'])) {
    foreach ($response['pm_api_results'] as $state => $json) {
      $pm_api_response = sbac_sso_parse_program_api_response($json);
      if ($pm_api_response) {
        $api_response[$state] = $pm_api_response;
        $response['sbac_tenancy_chains_validated'][$state] = $response['sbac_tenancy_chains_unvalidated'][$state];
      }
    }
  }

  return $api_response;
}

/**
 * Get the oauth access token.
 *
 * @return null
 */
function sbac_sso_get_program_management_oauth_access_token() {
  // POST to https://drc-dev-secure.opentestsystem.org/auth/oauth2/access_token?realm=/sbac
  // with Content-Type = application/x-www-form-urlenocded
  // and the following params:
  // grant_type=client_credentials
  // username=sbac.amp@example.com
  // password=amplify12345
  // client_id=pm
  // client_secret=sbac12345
  $request_creds = array(
    'grant_type' => 'password',
    'username' => 'pm.client@example.com',
    'password' => 'sbac12345',
    'client_id' => 'pm',
    'client_secret' => 'sbac12345'
  );
  $post = SBAC_SSO_PROGRAM_REQUEST_AUTH;
  $curl = curl_init();
  curl_setopt($curl, CURLOPT_URL, $post);
  curl_setopt($curl, CURLOPT_POST, 1);
  curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($request_creds));
  curl_setopt($curl, CURLOPT_HTTPHEADER, array('Content-Type: application/x-www-form-urlencoded'));
  curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);
  curl_setopt($curl, CURLOPT_SSLVERSION, 3);
  $result = curl_exec($curl);
  $http_status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
  curl_close($curl);
  unset($curl);

  $access_token = NULL;
  if ($http_status == 200 && $result) {
    $json_response = drupal_json_decode($result);
    $access_token = $json_response['access_token'];
  }
  return $access_token;
}

/**
 * Parses the Program Management API response.
 *
 * @param $json
 * @param $cache
 *
 * @return array
 */
function sbac_sso_parse_program_api_response($json, $cache = FALSE) {
  $api_response = array();
  $error = FALSE;

  if ($json) {
    if (isset($json['tenants']) === FALSE) {
      return $api_response;
    }

    $error = FALSE;
    foreach ($json['tenants'] as $index => $tenant) {
      if (isset($tenant['tenantSubscriptions'])) {
        $tenant_subscriptions = $tenant['tenantSubscriptions'];
        foreach ($tenant_subscriptions as $key => $subscription) {
          if (isset($subscription['component'])) {
            $component = $subscription['component'];
            if (($component['name'] == 'Digital Library' || $component['name'] == 'DigitalLibrary' ) && $subscription['inGoodStanding'] != TRUE) {
              $error = TRUE;
              break;
            }
          }
        }
      }
    }
  }

  if (!$error) {
    $api_response = $json;
    if (!$cache && isset($json['tenants'][0])) {
      $cached_results = variable_get('sbac_sso_pm_cached_results');
      foreach ($json['tenants'] as $key => $result_set) {
        $cached_results[$result_set['type']][$result_set['id']] = $result_set;
      }
      variable_set('sbac_sso_pm_cached_results', $cached_results);
    }
  }

  return $api_response;
}

/**
 * Try to load the user.
 *
 * @param $response
 * @param bool $multiple
 *
 * @return bool|mixed|stdClass
 */
function sbac_sso_determine_user($response, $multiple = FALSE) {
  if ($user = sbac_sso_load_user_by_uuid($response['entry_uuid'])) {
    if (!$multiple) {
      // First Name = givenName
      // Last Name = sn
      // Email = email
      // Take the tenancy chain you found |232093420|DL_EndUser|INSTITUTION|Amplify|SmarterBalanced|||cat|NC|||229|Daybreak School District|||942|Daybreak Central High|
      // The format of the sbacTenancyChain is as follows:
      // |RoleID|Name|Level|ClientID|Client|GroupOfStatesID|GroupOfStates|StateID|State|GroupOfDistrictsID|GroupOfDistricts|DistrictID|District|GroupOfInstitutionsID|GroupOfInstitutions|InstitutionID|Institution|
      // Preform a string split on this pile delimited string, and grab the
      // value from the positions for State, District, Insitution and update those
      // on the user record. If any are blank, update the DL User record accordingly.
      // If some error occurs in the data updating a user: Kick the user to an error
      // page with Smarter Balanced Contact information and a custom error code
      // (do not include the details pertaining to what the error code is connected to, just the ERROR CODE and NUMBER)
      $tenancy_chain = array_shift($response['sbac_tenancy_chains_validated']);
      if ($valid = sbac_sso_validate_state_by_name($tenancy_chain['state'])) {
        $term = current($valid);
        $user->field_state['und'][0]['tid'] = $term->tid;
      }
      $user->field_district_name['und'][0]['value'] = $tenancy_chain['district'];
      $user->field_school_name['und'][0]['value'] = $tenancy_chain['institution'];
    }
    $user->field_first_name['und'][0]['value'] = $response['given_name'];
    $user->field_last_name['und'][0]['value'] = $response['sn'];
    $user->mail = $response['email'];
    $user->data['session_index'] = $response['session_index'];
    $user = user_save($user);
    if (!$user) {
      drupal_goto('sbac-sso-error', array('query' => array('code' => 103)));
    }
  }
  elseif ($user = user_load_by_mail($response['email'])) {
    if (!$multiple) {
      // Record entryuuid to record for specified email address
      // Update all other fields passed in SAML assertion as described
      // in the first clause above. If some error occurs in the data updating a
      // user: Kick the user to an error page with Smarter Balanced Contact
      // information and a custom error code ( do not include the details pertaining
      // to what the error code is connected to, just the ERROR CODE and NUMBER :
      // ERROR CODE 103: Error updating user with user attributes that were passed.
      $tenancy_chain = array_shift($response['sbac_tenancy_chains_validated']);
      if ($valid = sbac_sso_validate_state_by_name($tenancy_chain['state'])) {
        $term = current($valid);
        $user->field_state['und'][0]['tid'] = $term->tid;
      }
      $user->field_district_name['und'][0]['value'] = $tenancy_chain['district'];
      $user->field_school_name['und'][0]['value'] = $tenancy_chain['institution'];
    }
    $user->field_first_name['und'][0]['value'] = $response['given_name'];
    $user->field_last_name['und'][0]['value'] = $response['sn'];
    $user->mail = $response['email'];
    $user->field_sso_uuid['und'][0]['value'] = $user_attributes['role_id'];
    $user->data['session_index'] = $response['session_index'];
    $user = user_save($user);
    if (!$user) {
      drupal_goto('sbac-sso-error', array('query' => array('code' => 103)));
    }
  }
  else {
    // Create a user record for this user with the end user role, and record
    // their userUUID to that record. Use all attributes that were updated
    // in first clause to create the record. If some error occurs in the data
    // creating a user: Kick the user to an error page with Smarter Balanced
    // Contact information and a custom error code ( do not include the details
    // pertaining to what the error code is connected to, just the ERROR CODE and NUMBER :
    // ERROR CODE 104: Error creating user with user attributes that were passed.
    $user = sbac_sso_create_user_record($response, $multiple);
    if (!$user) {
      drupal_goto('sbac-sso-error', array('query' => array('code' => 104)));
    }
  }
  return $user;
}

/**
 * Validates the state id.
 *
 * @param int $state_id
 *   The possible term ID.
 *
 * @return string
 */
function sbac_sso_validate_state_id($state_id) {
  $term = taxonomy_term_load($state_id);
  if ($term) {
    return $state_id;
  }
  return '';
}

/**
 * Validates the state name.
 *
 * @param string $state_name
 *   The possible term name.
 *
 * @return string
 */
function sbac_sso_validate_state_by_name($state_name) {
  $term = taxonomy_get_term_by_name($state_name, 'states');
  if ($term) {
    return $term;
  }
  return '';
}

/**
 * Create the user record.
 *
 * @param array $response
 *   The response from SAML.
 * @param bool $multiple
 *   Flag for if user has multiple tenancy chains
 *
 * @return bool|stdClass
 */
function sbac_sso_create_user_record($response, $multiple) {
  $new_user = new stdClass();
  $new_user->uid = 0;
  $new_user->cache = 0;
  $edit['name'] = $response['email'];
  $edit['pass'] = user_password(10);
  $edit['mail'] = $response['email'];
  $edit['init'] = $response['email'];
  $edit['timezone'] = date_default_timezone(TRUE);
  $edit['status'] = 1;
  if (!$multiple) {
    $tenancy_chain = array_shift($response['sbac_tenancy_chains_validated']);
    // Only create these fields if there is a single tenancy chain.
    if ($valid = sbac_sso_validate_state_by_name($tenancy_chain['state'])) {
      $term = current($valid);
      $edit['field_state']['und'][0]['tid'] = $term->tid;
    }
    if (isset($tenancy_chain['district'])) {
      $edit['field_district_name']['und'][0]['value'] = $tenancy_chain['district'];
    }
    if (isset($tenancy_chain['institution'])) {
      $edit['field_school_name']['und'][0]['value'] = $tenancy_chain['institution'];
    }
  }
  $edit['field_first_name']['und'][0]['value'] = $response['given_name'];
  $edit['field_last_name']['und'][0]['value'] = $response['sn'];
  $role_id = user_role_load_by_name('basic end user');
  $edit['roles'] = array(DRUPAL_AUTHENTICATED_RID => 'Authenticated User', $role_id->rid => $role_id->name);
  $edit['field_sso_uuid']['und'][0]['value'] = $response['entry_uuid'];
  $edit['data']['session_index'] = $response['session_index'];
  return user_save($new_user, $edit);
}

/**
 * Load the user by UUID.
 *
 * @param string $uuid
 *   The uuid to lookup
 *
 * @return bool
 */
function sbac_sso_load_user_by_uuid($uuid) {
  $user = FALSE;
  $sql  = "SELECT u.uid AS uid FROM {users} u ";
  $sql .= "JOIN {field_data_field_sso_uuid} uuid ON u.uid = uuid.entity_id ";
  $sql .= "WHERE uuid.field_sso_uuid_value = :uuid";
  $result = db_query($sql, array(':uuid' => $uuid))->fetchObject();
  if ($result) {
    $user = user_load($result->uid);
  }
  return $user;
}

/**
 * Generate the tenancy chain hash.
 *
 * @param $response
 *
 * @return string
 */
function sbac_sso_generate_tenancy_chain_hash($response) {
  $hash_array = array();
  foreach ($response['sbac_tenancy_chains_validated'] as $state => $chain) {
    $hash_array[] = implode(',', $chain);
  }
  $hash = implode(',', $hash_array);
  $md5_hash = md5($hash);
  return $md5_hash;
}

/**
 *
 *
 * @param $user
 * @param $multiple
 * @param $response
 * @param $hash
 */
function sbac_sso_log_user_in($user, $multiple, $response, $hash) {
  // If the user is marked as blocked.
  if ($user->status == 0) {
    // Kick the user to an error page with Smarter Balanced Contact information
    // and a custom error code ( do not include the details pertaining to what
    // the error code is connected to, just the ERROR CODE and NUMBER :
    // ERROR CODE 200: Error updating user with user attributes that were passed.
    drupal_goto('sbac-sso-error', array('query' => array('code' => 200)));
  }

  if (isset($_REQUEST['RelayState']) && $_REQUEST['RelayState'] != NULL) {
    global $base_url;
    $relay_state = $_REQUEST['RelayState'];
    $relay_state = str_replace($base_url, '', $relay_state);
    if ($relay_state) {
      $_SESSION['sbac-sso']['relay'] = $relay_state;
    }
  }

  // Log user in.
  $form_state['uid'] = $user->uid;
  $_SESSION['uid'] = $user->uid;
  $_SESSION['sbac-sso']['multiple'] = $multiple;
  $_SESSION['sbac-sso']['response'] = $response;
  $_SESSION['sbac-sso']['hash'] = $hash;
  user_login_submit(array(), $form_state);
}

/**
 * Get the SAML assertion.
 *
 * @return string
 */
function sbac_sso_saml_assertion() {
  global $base_url;
  $string = user_password(10);
  $date = date('Y-m-d') . 'T' . date('H:i:s') . '.073Z';
  $saml_assertion = '<samlp:AuthnRequest ID="' . uniqid('_' . $string, TRUE) . '" Version="2.0" IssueInstant="' . $date . '" Destination="' . SBAC_SSO_URL . '" ForceAuthn="false" IsPassive="false" ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" AssertionConsumerServiceURL="' . $base_url . '/sbac-sso-consume" xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"><saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">' . $base_url . '</saml:Issuer><samlp:NameIDPolicy AllowCreate="true" /></samlp:AuthnRequest>';
  error_log($saml_assertion);
  return $saml_assertion;
}

/**
 * Get the SAML Logout Assertion.
 *
 * @return string
 */
function sbac_sso_logout_assertion() {
  global $base_url;
  global $user;
  $string = user_password(10);
  $date = date('Y-m-d') . 'T' . date('H:i:s') . '.073Z';
  $logout_url = $base_url . '/sbac-sso-logout';

  $logout_assertion = '
  <samlp:LogoutRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"  xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" ID="' . uniqid('_' . $string, TRUE) . '" Version="2.0" Destination="' . $logout_url . '" IssueInstant="' . $date . '">
  <saml:Issuer>' . $base_url . '</saml:Issuer>
  <samlp:SessionIndex>' . $user->data['session_index'] . '</samlp:SessionIndex>
  <saml:NameID>' . sha1($string) . '</saml:NameID>
  </samlp:LogoutRequest>';
  return $logout_assertion;
}

/**
 * Implements hook_cron().
 *
 * Stores the tenants chain list for Program Management API.
 * Used later to retrieve local copy vs API call each
 * user login attempt.
 */
function sbac_sso_cron() {
  $access_token = sbac_sso_get_program_management_oauth_access_token();
  if ($access_token) {
    $post = SBAC_SSO_PROGRAM_OAUTH_API_LIST;
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $post);
    curl_setopt($curl, CURLOPT_HTTPHEADER, array(
      'Authorization: Bearer ' . $access_token,
    ));
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);
    curl_setopt($curl, CURLOPT_SSLVERSION,3);
    $result = curl_exec($curl);
    $http_status = curl_getinfo($curl, CURLINFO_HTTP_CODE);
    curl_close($curl);
    if ($result && $http_status == 200) {
      $json_responses = drupal_json_decode($result);
      $cached_results = variable_get('sbac_sso_pm_cached_results');
      foreach ($json_responses as $json) {
        $cached_results[$json['type']][$json['id']] = $json;
      }
      variable_set('sbac_sso_pm_cached_results', $cached_results);
    }
  }
}

/**
 * Determines if the user has multiple tenancy chains or not.
 *
 * @param $response
 *
 * @return bool
 */
function sbac_sso_determine_multiple_tenancy_chains($response) {
  $multiple = FALSE;
  if (count($response['sbac_tenancy_chains_validated']) > 1) {
    $multiple = TRUE;
  }
  return $multiple;
}

/**
 * Displays the conflicting profile page / form.
 */
function sbac_sso_conflicting_profile() {
  $form = drupal_get_form('sbac_sso_conflicting_profile_form');
  return $form;
}

/**
 * Implements hook_form_alter().
 *
 * @param $form
 * @param $form_state
 * @return array
 */
function sbac_sso_conflicting_profile_form($form, &$form_state) {
  $form = array();

  $form['#attached']['js'] = array(
    drupal_get_path('module', 'sbac_sso') . '/js/sbac_sso.conflicting_profile.js',
  );

  $form['#attached']['css'] = array(
    drupal_get_path('module', 'sbac_sso') . '/css/sbac_sso.conflicting_profile.css',
  );

  $form['information'] = array(
    '#prefix' => '<div class="sbac-conflict-wrapper">',
    '#markup' => t('Your account is associated to multiple states. Please choose the profile below that accurately reflects your information for the Digital Library.'),
  );

  $choices = array();
  $tenancy_chains = $_SESSION['sbac-sso']['response']['sbac_tenancy_chains_validated'];
  foreach ($tenancy_chains as $state => $chain) {
    $text = '<strong>State:</strong>' . strtoupper($state);
    if ($chain['district'] != NULL) {
      $text .= ', <strong>District:</strong>' . ucwords(strtolower($chain['district']));
    }
    if ($chain['institution'] != NULL) {
      $text .= ', <strong>Institution:</strong>' .  ucwords(strtolower($chain['institution']));
    }
    $choices[$state] = $text;
  }

  $form['choices'] = array(
    '#type' => 'radios',
    '#options' => $choices,
    '#attributes' => array('class' => array('sbac-sso-conflict-choice')),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'OK',
    '#attributes' => array('class' => array('sbac-sso-conflict-submit')),
    '#suffix' => '</div>',
  );

  return $form;
}

/**
 * Implements hook_form_submit().
 *
 * @param $form
 * @param $form_state
 */
function sbac_sso_conflicting_profile_form_submit($form, &$form_state) {
  global $user;
  $account = user_load($user->uid);
  // on submit, update user profile and direct to next step in workflow.
  $tenancy_chains = $_SESSION['sbac-sso']['response']['sbac_tenancy_chains_validated'];
  foreach ($tenancy_chains as $state => $chain) {
    if (strtoupper($state) == $form_state['values']['choices']) {
      if ($valid = sbac_sso_validate_state_by_name($chain['state'])) {
        $term = current($valid);
        $account->field_state['und'][0]['tid'] = $term->tid;
      }
      // Update the district.
      if (isset($chain['district']) && $chain['district'] != NULL) {
        $account->field_district_name['und'][0]['value'] = ucwords(strtolower($chain['district']));
      }
      else {
        $account->field_district_name['und'][0]['value'] = NULL;
      }
      // Update the institution.
      if (isset($chain['institution']) && $chain['institution'] != NULL) {
        $account->field_school_name['und'][0]['value'] = ucwords(strtolower($chain['institution']));
      }
      else {
        $account->field_school_name['und'][0]['value'] = NULL;
      }
      $account->field_sso_tenancy_hash['und'][0]['value'] = $_SESSION['sbac-sso']['hash'];
      break;
    }
  }
  // Determine if they need to go to user-setup page.
  $user_setup = FALSE;
  if (!isset($account->data['login']) && (empty($account->field_position) || empty($account->field_subject_s_) || empty($account->field_grade_level_s_) || empty($account->field_special_populations))) {
    $user_setup = TRUE;
  }
  if (!$user_setup) {
    // If they are not going to user-setup, then update login information.
    sbac_user_update_data($account, $edit);
  }
  // Save the updates.
  user_save($account);
  // Remove the SESSION variables.
  unset($_SESSION['sbac-sso']['multiple']);
  unset($_SESSION['sbac-sso']['response']);
  unset($_SESSION['sbac-sso']['hash']);
  unset($_SESSION['sbac-sso']['conflicting_profile']);
  // If user has yet to fill in required Title, Subjects, Grades and Student Population fields because they are a new user
  if ($user_setup) {
    drupal_goto('sbac-user/setup');
  }
  else {
    sbac_user_redirect_on_login();
  }
}
