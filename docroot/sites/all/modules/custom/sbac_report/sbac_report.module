<?php
/**
 * @file
 * Code for the SBAC Report feature.
 */

include_once 'sbac_report.features.inc';

/**
 * Implements hook_update_projects_alter().
 *
 * @param $projects
 */
function sbac_report_update_projects_alter(&$projects) {
  unset($projects['sbac_report']);
}

/**
 * Implements hook_menu().
 */
function sbac_report_menu() {
  $items['reports'] = array(
    'title' => 'Reports',
    'file' => 'sbac_report.pages.inc',
    'page callback' => 'sbac_report_individual',
    'access callback' => 'sbac_report_user_access',
    'type' => MENU_NORMAL_ITEM,
    'menu_name' => 'main-menu',
    'weight' => -10,
  );

  $items['sne/autocomplete'] = array(
    'title' => 'Autocomplete SNE Names',
    'file' => 'sbac_report.pages.inc',
    'page callback' => 'sbac_report_sne_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['reports/%node/info'] = array(
    'title' => 'Resource Report Information',
    'file' => 'sbac_report.pages.inc',
    'page callback' => 'sbac_report_individual_modal',
    'page arguments' => array(1),
    'access callback' => 'sbac_report_user_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Custom user access.
 */
function sbac_report_user_access() {
  global $user;
  $roles = $user->roles;

  return $user->uid == 1 ||
    in_array('DLRB member', $roles) ||
    in_array('digital library administrator', $roles) ||
    in_array('system administrator', $roles) ||
    sbac_report_is_slt($user);
}

/**
 * Implements hook_theme().
 */
function sbac_report_theme($existing, $type, $theme, $path) {
  $themes = array();
  $module_path = drupal_get_path('module', 'sbac_report');

  $themes['sbac_report_individual'] = array(
    'template' => 'templates/sbac-report-individual',
    'path' => $module_path,
    'file' => 'sbac_report.preprocess.inc',
    'preprocess functions' => array(
      'template_preprocess',
      'sbac_report_preprocess_sbac_report_individual',
    ),
  );

//  $themes['sbac_report_csv'] = array(
//      'template' => 'templates/sbac-report-csv',
//      'path' => $module_path,
//      'file' => 'sbac_report.preprocess.inc',
//      'preprocess functions' => array(
//          'template_preprocess',
//          'sbac_report_preprocess_sbac_report_csv',
//      ),
//  );
  $themes['sbac_report_date_range_dropdown'] = array(
    'template' => 'templates/sbac-report-date-range-dropdown',
    'path' => $module_path,
    'arguments' => array('which'=>'','date_display' => NULL, 'ago_30' => NULL, 'ago_60' => NULL, 'ago_90' => NULL), //default values
    'preprocess functions' => array(
      'template_preprocess',
    ),
  );
/*
  $themes['sbac_report_user_group_dropdown'] = array(
    'template' => 'templates/sbac-report-user-group-dropdown',
    'path' => $module_path,
    'arguments' => sbac_report_user_group_options(),
    'preprocess functions' => array(
      'template_preprocess',
    ),
  );
*/

  $themes['views_view_fields__sne_details'] = array(
    'template' => 'views-view-fields--sne-details',
    'path' => $module_path . '/templates/views',
    'arguments' => array('view' => NULL, 'options' => NULL, 'row' => NULL),
    'orginal hook' => 'views_view_fields',
    'preprocess functions' => array(
      'template_preprocess',
      'template_preprocess_views_view_fields',
    ),
  );

  // Take care of the pager and "items per page".
  $themes['views_view__contributed_resources'] = array(
    'template' => 'views-view--contributed-resources',
    'path' => $module_path . '/templates/views',
    'arguments' => array('view' => NULL),
    'orginal hook' => 'views_view',
    'preprocess functions' => array(
      'template_preprocess',
      'template_preprocess_views_view',
    ),
  );

  return $themes;
}

/**
 * Individual Report filter form.
 */
function sbac_report_individual_form($form, &$form_state) {
  $form = array();

  // Make sure to load this after autocomplete.js
  // @see sbac_report.individual.js
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'sbac_report') .
      '/js/sbac_report.individual.js' => array('weight' => 99),
  );

  $form['state'] = array(
    '#type' => 'select',
    '#title' => t('Choose a state'),
    '#options' => sbac_report_state_options(),
    '#multiple' => FALSE,
    '#default_value' => sbac_report_get_default_state_tid(),
    '#ajax' => array(
      'callback' => 'sbac_report_state_ajax',
    ),
    '#required' => TRUE,
  );

  $date_options = sbac_report_date_range_options();
  $session_date_range = sbac_report_get_session_value('date_range', 'range');

  // If there was no date range stored in SESSION.
  // Default to the "Last 30 Days".
  if (empty($session_date_range)) {
    $session_date_range = $date_options['Last 30 Days'];
    $date_display = t('Last 30 Days');
  }
  // If there is, we get the display text "Last 60 Days", "Last 90 Days", etc.
  elseif ($key = array_search($session_date_range, $date_options)) {
    $date_display = t($key);
  }
  // If it was a custom selection, format the string.
  else {
    $date_display = sbac_report_format_date_range($session_date_range);
  }

  sbac_report_build_date_range_dropdown($form, $session_date_range, $date_display, $date_options, '');

  $form['sne'] = array(
    '#type' => 'textfield',
    '#title' => t('Choose a SNE'),
    '#autocomplete_path' => 'sne/autocomplete',
    '#required' => TRUE,
    '#size' => 30,
    '#default_value' => sbac_report_get_session_value('sne', 'name'),
  );

  // Hidden field to store the selected uid.
  // When the autocomplete suggetion is selected,
  // the uid value will be set here.
  // @see sbac_report.js
  $form['uid'] = array(
    '#type' => 'hidden',
    '#default_value' => sbac_report_get_session_value('sne', 'uid'),
    '#attributes' => array(
      'id' => 'sne-uid-field',
    ),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['#validate'][] = 'sbac_report_individual_form_validate';

  return $form;
}

/**
 * Individual Report: form validate.
 */
function sbac_report_individual_form_validate($form, &$form_state) {
  if (empty($form_state['values']['uid']) || !is_numeric($form_state['values']['uid'])) {
    form_set_error('sne', t('Please type and select an existing SNE'));
  }
}

/**
 * Individual Report: Form submit.
 * Store in SESSION:
 * $_SESSION['sbac_report'] = array(
 *   'state' => array('name' => 'California', 'tid' => 123),
 *   'date_range' => array('range' => '20130515--20140515'),
 *   'sne' => array('uid' => 1, 'name' => 'first last'),
 * );
 */
function sbac_report_individual_form_submit($form, &$form_state) {
  // State.
  $state_tid = $form_state['values']['state'];
  $_SESSION['sbac_report']['state']['tid'] = $state_tid;
  if (!is_numeric($state_tid) && $state_tid == 'all') {
    $_SESSION['sbac_report']['state']['name'] = 'all';
  }
  else {
    $state_options = $form['state']['#options'];
    $_SESSION['sbac_report']['state']['name'] = $state_options[$state_tid];
  }

  // Time range.
  $_SESSION['sbac_report']['date_range']['range'] = $form_state['values']['date_range'];

  // SNE.
  $_SESSION['sbac_report']['sne']['uid'] = $form_state['values']['uid'];
  $_SESSION['sbac_report']['sne']['name'] = $form_state['values']['sne'];
}


/**
 * CSV Report filter form.
 */
function sbac_report_csv_form($form, &$form_state) {
  $form = array();

  // Make sure to load this after autocomplete.js
  // @see sbac_report.csv.js
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'sbac_report') .
    '/js/sbac_report.csv.js' => array('weight' => 99),
  );

  $form['state'] = array(
    '#type' => 'select',
    '#title' => t('Choose a state'),
    '#options' => sbac_report_state_options(),
    '#multiple' => FALSE,
    '#default_value' => sbac_report_get_default_state_tid(),
    '#ajax' => array(
      'callback' => 'sbac_report_state_ajax',
    ),
    '#required' => TRUE,
  );

  $date_options = sbac_report_date_range_options();
  $session_date_range = sbac_report_get_session_value('date_range', 'range');

  // If there was no date range stored in SESSION.
  // Default to the "Last 30 Days".
  if (empty($session_date_range)) {
    $session_date_range = $date_options['Last 30 Days'];
    $date_display = t('Last 30 Days');
  }
  // If there is, we get the display text "Last 60 Days", "Last 90 Days", etc.
  elseif ($key = array_search($session_date_range, $date_options)) {
    $date_display = t($key);
  }
  // If it was a custom selection, format the string.
  else {
    $date_display = sbac_report_format_date_range($session_date_range);
  }

  sbac_report_build_date_range_dropdown($form, $session_date_range, $date_display, $date_options, '1');

  // TODO: user groups instead of SNE.
  //$user_group_options = sbac_report_user_group_options();
  $user_group_options = array(
    'End Users',
    'Contributors',
    'Reviewers',
    'Posters',
    'SNE Members',
    'SLT Members',
    'Moderators',
    'Facilitators',
    'DLRB Members',
    'Admins',
  );

  $form['user_group_dropdown'] = array(
    '#type' => 'markup',
    '#markup' => theme('sbac_report_user_group_dropdown',
      array('user_group_options' => $user_group_options,
      )
    )
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['#validate'][] = 'sbac_report_csv_form_validate';

  return $form;
}

/**
 * CSV Report: form validate.
 */
function sbac_report_csv_form_validate($form, &$form_state) {
  if (empty($form_state['values']['uid']) || !is_numeric($form_state['values']['uid'])) {
    form_set_error('sne', t('Please type and select an existing SNE'));
  }
}

/**
 * CSV Report: Form submit.
 * Store in SESSION:
 * $_SESSION['sbac_report'] = array(
 *   'state' => array('name' => 'California', 'tid' => 123),
 *   'date_range' => array('range' => '20130515--20140515'),
 *   TODO: user group 'sne' => array('uid' => 1, 'name' => 'first last'),
 * );
 */
function sbac_report_csv_form_submit($form, &$form_state) {
  // State.
  $state_tid = $form_state['values']['state'];
  $_SESSION['sbac_report']['state']['tid'] = $state_tid;
  if (!is_numeric($state_tid) && $state_tid == 'all') {
    $_SESSION['sbac_report']['state']['name'] = 'all';
  }
  else {
    $state_options = $form['state']['#options'];
    $_SESSION['sbac_report']['state']['name'] = $state_options[$state_tid];
  }

  // Time range.
  $_SESSION['sbac_report']['date_range']['range'] = $form_state['values']['date_range'];

  // TODO: change this to user group: SNE.
  $_SESSION['sbac_report']['sne']['uid'] = $form_state['values']['uid'];
  $_SESSION['sbac_report']['sne']['name'] = $form_state['values']['sne'];
}

/**
 * Build the date range dropdown for the filter form.
 *
 * @param array $form
 *   The form array passed by reference.
 * @param string $default_date_range
 *   The default value for the date range field in format Ymd--Ymd.
 * @param string $date_display
 *   The date display on the dropdown top level.
 * @param array $date_options
 *   An associative array of default date options.
 */
function sbac_report_build_date_range_dropdown(&$form, $default_date_range, $date_display, $date_options, $which) {

  $form['#attached']['js'][] = drupal_get_path('module', 'sbac_report') . '/js/sbac_report.date_dropdown.js';

  // Hidden, used to pass the value through submit handler.
  // Value is set when the user selects an item in the dropdown.
  // @see sbac_report.js
  $form['date_range'+$which] = array(
    '#type' => 'hidden',
    '#title' => t('Choose a time period'),
    '#default_value' => $default_date_range,
    '#attributes' => array(
      'id' => 'date-range-field'+$which,
    ),
  );

  $form['date_range_dropdown'+$which] = array(
    '#type' => 'markup',
    '#markup' => theme('sbac_report_date_range_dropdown',
      array(
        'which' => $which,
        'date_display' => $date_display ? $date_display : t('Last 30 Days'),
        'ago_30' => $date_options['Last 30 Days'],
        'ago_60' => $date_options['Last 60 Days'],
        'ago_90' => $date_options['Last 90 Days'],
      )
    )
  );

  $form['from_date'+$which] = array(
    '#id' => 'from-date'+$which,
    '#title' => t('From'),
    '#type' => 'date_popup',
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-3:+3',
    '#datepicker_options' => array(),
  );

  $form['to_date'+$which] = array(
    '#id' => 'to-date'+$which,
    '#title' => t('To'),
    '#type' => 'date_popup',
    '#date_type' => DATE_DATETIME,
    '#date_format' => 'm/d/Y',
    '#date_increment' => 1,
    '#date_year_range' => '-3:+3',
    '#datepicker_options' => array(),
    '#suffix' => '</div></div>', // Closing tags for the dropdown template.
  );
}

/**
 * Options for the state field.
 */
function sbac_report_state_options() {
  global $user;
  $roles = $user->roles;
  $options = array();
  $first_only =  FALSE;

  // Admin user can select between state.
  if ($user->uid == 1 ||
    in_array('DLRB member', $roles) ||
    in_array('digital library administrator', $roles) ||
    in_array('system administrator', $roles)) {

    $options['all'] = t('All');
    // Return if we only want the first one.
    if (isset($first_only) && $first_only) {
      return $options;
    }
    
    $states = taxonomy_vocabulary_machine_name_load("states");
    $vid = $states->vid;
    $terms = taxonomy_get_tree($vid);
    foreach ($terms as $key => $val) {
      $options[$val->tid] = $val->name;
    }
  }
  // SLT user can only select their own states.
  elseif (sbac_report_is_slt($user)) {
    $result = db_select('field_data_field_state', 'fs')
      ->fields('fs', array('field_state_tid'))
      ->condition('entity_type', 'user')
      ->condition('entity_id', $user->uid)
      ->orderBy('field_state_tid')
      ->execute();
    foreach ($result as $record) {
      $tid = $record->field_state_tid;
      $state_term = taxonomy_term_load($tid);
      $state = $state_term->name;
      $options[$tid] = $state;
      // Return if we only want the first one.
      if ($first_only) {
        return $options;
      }
    }
  }

  return $options;
}

/**
 * Get default state.
 */
function sbac_report_get_default_state_tid() {
  $state_tid = sbac_report_get_session_value('state', 'tid');
  if (empty($state_tid)) {
    $state = sbac_report_state_options(TRUE);
    $state_tid = key($state);
  }
  return $state_tid;
}

/**
 * Check if the user is an SLT.
 *
 * @param object $account
 *   User object.
 *
 * @return bool
 *   True if an SLT. False otherwise.
 */
function sbac_report_is_slt($account) {
  // First check if the user has resource publisher role.
  if (in_array('resource publisher', $account->roles)) {
    $result = db_select('field_data_field_slt_member', 'slt')
      ->fields('slt', array('field_slt_member_value'))
      ->condition('entity_type', 'user')
      ->condition('entity_id', $account->uid)
      ->condition('field_slt_member_value', '1')
      ->execute();
    $count = $result->rowCount();
    return $result->rowCount();
  }
  return FALSE;
}

/**
 * Options for the date range field.
 */
function sbac_report_date_range_options() {
  $today = format_date(REQUEST_TIME, 'custom', 'Ymd');
  $ago_30 = format_date(strtotime('30 days ago'), 'custom', 'Ymd');
  $ago_60 = format_date(strtotime('60 days ago'), 'custom', 'Ymd');
  $ago_90 = format_date(strtotime('90 days ago'), 'custom', 'Ymd');
  $options = array(
    'Last 30 Days' => $ago_30 . '--' . $today,
    'Last 60 Days' => $ago_60 . '--' . $today,
    'Last 90 Days' => $ago_90 . '--' . $today,
  );

  return $options;
}

/**
 * Options for the user groups.
 */
function sbac_report_user_group_options() {

  $options = array(
    'End Users' => 'end-users',
    'Contributors' => 'contributors',
    'Reviewers' => 'reviewers',
    'Posters' => 'posters',
    'SNE Members' => 'sne-members',
    'SLT Members' => 'snl-members',
    'Moderators' => 'moderators',
    'Facilitators' => 'facilitators',
    'DLRB Members' => 'dlrb-members',
    'Admins' => 'admins',
  );

  return $options;
}

/**
 * Get the stored SESSION values.
 * @see submit handler.
 *
 * @param string $field
 *   The field name: state, date_range, sne.
 * @param string $key
 *   The type of the value to be returned.
 *   e.g: for state field: "tid", "name".
 *        for date field: "range".
 *        for SNE field: "uid".
 *
 * @return string|int
 *   The value stored in SESSION.
 */
function sbac_report_get_session_value($field, $key) {
  if (isset($_SESSION['sbac_report'][$field][$key]) && !empty($_SESSION['sbac_report'][$field][$key])) {
    $value = $_SESSION['sbac_report'][$field][$key];
    // If the stored date range is invalid, unset everything to prevent further error.
    if ($field == 'date_range' && !sbac_report_validate_date_range($value)) {
      unset($_SESSION['sbac_report']);
      $value = NULL;
    }
    return check_plain($value);
  }
  return NULL;
}

/**
 * Ajax callback for the State field.
 * Store the selected state in SESSION
 * so the autocomplete for SNE text field is filtered based on the state.
 */
function sbac_report_state_ajax($form, &$form_state) {
  if (isset($form_state['values']['state'])) {
    $state_tid = $form_state['values']['state'];
    $_SESSION['sbac_report']['state']['tid'] = $state_tid;
    if (!is_numeric($state_tid) && $state_tid == 'all') {
      $_SESSION['sbac_report']['state']['name'] = 'all';
    }
    else {
      $state_options = $form['state']['#options'];
      $_SESSION['sbac_report']['state']['name'] = $state_options[$state_tid];
    }
  }
  return $form;
}

/**
 * Validate the date range string used for Views Contextual Range filter.
 */
function sbac_report_validate_date_range($str) {
  if (!preg_match("/^\d{4}\d{2}\d{2}--\d{4}\d{2}\d{2}$/", $str)) {
    return FALSE;
  }
  // If the regex check passed, check again by creating a DateTime object.
  else {
    $date_range = contextual_range_filter_split($str);
    $from_date = DateTime::createFromFormat("Ymd", $date_range[0]);
    $to_date = DateTime::createFromFormat("Ymd", $date_range[1]);
    return is_object($from_date) && is_object($to_date);
  }
}

/**
 * Format the date range 'Ymd--Ymd' to 'm/d/Y to m/d/Y'.
 */
function sbac_report_format_date_range($str) {
  $date_range = contextual_range_filter_split($str);
  $from_date = DateTime::createFromFormat("Ymd", $date_range[0]);
  $to_date = DateTime::createFromFormat("Ymd", $date_range[1]);

  if (is_object($from_date) && is_object($to_date)) {
    $from_date_format = $from_date->format("m/d/Y");
    $to_date_format = $to_date->format("m/d/Y");
    return t($from_date_format . ' to ' . $to_date_format);
  }
  else {
    return '';
  }
}

/**
 * Custom embed view. Return NULL if no result.
 */
function sbac_report_embed_view($name, $display_id = 'default') {
  $args = func_get_args();
  array_shift($args); // remove $name.
  if (count($args)) {
    array_shift($args); // remove $display_id.
  }

  $view = views_get_view($name);
  if (is_object($view)) {
    if (is_array($args)) {
      $view->set_arguments($args);
    }
    $preview = $view->preview($display_id);
    if (!empty($view->result)) {
      return $preview;
    }
  }

  return NULL;
}

/**
 * Implements hook_views_query_alter().
 *
 * Fix the broken contextual filter for eck "created" date field.
 * Current ECK version: 7.x-2.0-rc2
 *
 * TODO: !! need to sync the feedback entity's date record with the resource's submission date
 * (i.e: the "created" timestamp, @see sbac_report_workbench_moderation_transition),
 * since the submission date should always be the base for the date range filter.
 */
function sbac_report_views_query_alter(&$view, &$query) {
  if ($view->name == 'gate_keeping_reviews') {
    foreach ($query->where as &$condition_group) {
      foreach ($condition_group['conditions'] as &$condition) {
        if ($condition['operator'] == 'formula' && strpos($condition['field'], 'eck_feedback. SECOND') !== FALSE) {
          $condition['field'] = str_replace('eck_feedback. SECOND', 'eck_feedback.created SECOND', $condition['field']);
          break 2;
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter.
 */
function sbac_report_form_views_exposed_form_alter(&$form, &$form_state) {
  switch ($form['#id']) {
    case 'views-exposed-form-contributed-resources-resources-details':
      if (isset($form['items_per_page'])) {
        foreach ($form['items_per_page']['#options'] as $key => $val) {
          if (is_numeric($key)) {
            $form['items_per_page']['#options'][$key] = t('Up to !num', array('!num' => $val));
          }
        }
      }  
      break;
  }
}


/**
 * Calculate the Gate Keeping reviews rate.
 *
 * @param int $uid
 *   User ID or 'all' for all SNEs.
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @param array
 *   An associative array of the reviews rate.
 */
function sbac_report_gate_keeping_reviews_rate($uid, $date_range) {
  $rate = array(
    'total' => 0,
    'acceptance' => 0,
    'return' => 0,
  );

  $result = views_get_view_result('gate_keeping_reviews', 'gk_reviews', $uid, $date_range);
  if (!empty($result)) {
    $rate['total'] = $result[0]->id ? $result[0]->id : 0;
    $rate['acceptance'] = $result[0]->eck_feedback_met_criteria ? $result[0]->eck_feedback_met_criteria : 0;
    $rate['return'] = $rate['total'] - $rate['acceptance'];
  }
  return $rate;
}

/**
 * Returns the accepted gate keeper results for the given user and data range.
 *
 * @param int $uid
 *   User ID or 'all' for all SNEs.
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 *   An associative array of the gate keeper reviews.
 */
function sbac_report_get_ind_accepted_gate_keeper($uid, $date_range) {
  $accepted_gk = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    uid = :uid AND
    status = :status AND
    completed = :completed AND
    met_criteria = :met_criteria AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // so an accepted GK is status 1, completed 1, met_criteria 1
  $result = db_query($sql, array(':type' => 'gate_keeper', ':uid' => $uid, ':status' => 1, ':completed' => 1, ':met_criteria' => 1, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $accepted_gk[] = $row;
  }
  return $accepted_gk;
}

/**
 * Returns the returned gate keeper results for the given user and data range.
 *
 * @param int $uid
 *   User ID or 'all' for all SNEs.
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 *   An associative array of the gate keeper reviews.
 */
function sbac_report_get_ind_returned_gate_keeper($uid, $date_range) {
  $returned_gk = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    uid = :uid AND
    status = :status AND
    completed = :completed AND
    met_criteria = :met_criteria AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // so an accepted GK is status 1, completed 1, met_criteria 0
  $result = db_query($sql, array(':type' => 'gate_keeper', ':uid' => $uid, ':status' => 1, ':completed' => 1, ':met_criteria' => 0, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $returned_gk[] = $row;
  }
  return $returned_gk;
}

/**
 * Returns the accepted gate keeper results for all users and the data range.
 *
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 *   An associative array of the gate keeper reviews.
 */
function sbac_report_get_all_accepted_gate_keeper($date_range) {
  $accepted_gk = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    status = :status AND
    completed = :completed AND
    met_criteria = :met_criteria AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // so an accepted GK is status 1, completed 1, met_criteria 1
  $result = db_query($sql, array(':type' => 'gate_keeper', ':status' => 1, ':completed' => 1, ':met_criteria' => 1, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $accepted_gk[] = $row;
  }
  return $accepted_gk;
}

/**
 * Returns the returned gate keeper results for all users and the data range.
 *
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 *   An associative array of the gate keeper reviews.
 */
function sbac_report_get_all_returned_gate_keeper($date_range) {
  $returned_gk = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    status = :status AND
    completed = :completed AND
    met_criteria = :met_criteria AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // so an accepted GK is status 1, completed 1, met_criteria 0
  $result = db_query($sql, array(':type' => 'gate_keeper', ':status' => 1, ':completed' => 1, ':met_criteria' => 0, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $returned_gk[] = $row;
  }
  return $returned_gk;
}

/**
 * Gets all the reviews in the "in review" state given the UID and date range.
 *
 * @param int $uid
 *   User ID or 'all' for all SNEs.
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 */
function sbac_report_get_in_reviews($uid, $date_range) {
  $in_review = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    uid = :uid AND
    status = :status AND
    completed = :completed AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // anything with status = 1 and completed = 0 is an active, on-going review
  $result = db_query($sql, array(':type' => 'qc', ':uid' => $uid, ':status' => 1, ':completed' => 0, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $in_review[] = $row;
  }

  return $in_review;
}

/**
 * Gets all the reviews in the "completed" state given the UID and date range.
 *
 * @param int $uid
 *   User ID or 'all' for all SNEs.
 * @param string $date_range
 *   The date range in format 'Ymd--Ymd'.
 *
 * @return array
 */
function sbac_report_get_completed_reviews($uid, $date_range) {
  $completed = array();

  $sql = <<<SQL

  SELECT
    id,
    uid,
    node_id
  FROM {eck_feedback}
  WHERE
    type = :type AND
    uid = :uid AND
    status = :status AND
    completed = :completed AND
    DATE_FORMAT((DATE_ADD('19700101', INTERVAL created SECOND) + INTERVAL -25200 SECOND), '%Y%m%d') BETWEEN :from_date AND :to_date

SQL;

  $dates = explode('--', $date_range);
  $from_date = $dates[0];
  $to_date = $dates[1];

  // anything with status = 1 and completed = 1 is completed.
  $result = db_query($sql, array(':type' => 'qc', ':uid' => $uid, ':status' => 1, ':completed' => 1, ':from_date' => $from_date, ':to_date' => $to_date));
  foreach ($result as $row) {
    $completed[] = $row;
  }

  foreach ($completed as $key => $user_completed_review) {
    $feedback = _sbac_resource_determine_feedback($user_completed_review->node_id, 'qc', $uid, 1, FALSE, 1, 'set', TRUE);
    if (count($feedback) != 2) { // two other reviewers
      unset($completed[$key]);
    }
  }

  return $completed;
}

/**
 *
 *
 * @param $reviews
 *
 * @return array
 */
function sbac_report_get_average_consistency_rate_acr($uid, $reviews) {
  $consistency_rates = array();
  foreach($reviews as $review) {
    $consistency_rates[] = sbac_report_get_posting_consistency_rate($uid, $review);
  }

  $rate = 0;
  foreach ($consistency_rates as $consistency_rate) {
    $rate += $consistency_rate;
  }

  if ($consistency_rates && count($consistency_rates) != 0) {
    $average_consistency_rate = abs($rate / count($consistency_rates));
    return $average_consistency_rate;
  }
  else {
    return 0;
  }
}

/**
 *
 * @param $reviews
 *
 * @return string
 */
function sbac_report_get_posting_consistency_rate($uid, $review = NULL) {
  $consistency_rate = NULL;
  if ($review == NULL) {
    return $consistency_rate;
  }


  // Get the Reviewer's A, B and C options to determine rate.
  // Ordering of the result set is the order of the reviews.
  // First record changed = Reviewer A etc.
  $sql = <<<SQL

    SELECT *
    FROM eck_feedback
      AS f
    JOIN field_data_field_rec_options
      AS o
    ON f.id = o.entity_id
    WHERE f.node_id = :nid
      AND f.type = :type
      AND f.status = :feedback_status
      AND f.completed = :feedback_completed
      AND o.deleted = :deleted
    ORDER BY f.changed

SQL;

  //  Values as stored in DB are:
  //  0|Do not recommend
  //  1|Recommend with Revisions
  //  2|Recommend
  //  3|Recommend with Distinction
  $review_data = db_query($sql, array(':nid' => $review->node_id, ':type' => 'qc', ':feedback_status' => 1, ':feedback_completed' => 1, ':deleted' => 0))->fetchAll();
  if ($review_data) {
    $reviewer_alpha = array(0 => 'Reviewer A', 1 => 'Reviewer B', 2 => 'Reviewer C');
    $math_value = 1; $count = 1;
    $math_elements = array();
    foreach ($review_data as $review) {
      switch ($review->field_rec_options_value) {
        case '0':
          $math_value = 1;
          break;
        case '1':
          $math_value = 2;
          break;
        case '2':
          $math_value = 3;
          break;
        case '3':
          $math_value = 4;
          break;
      }

      if ($uid == $review->uid) {
        $math_elements[$reviewer_alpha[0]] = $math_value;
      }
      else {
        $math_elements[$reviewer_alpha[$count]] = $math_value;
        $count++;
      }
    }

    if ($math_elements) {
      $consistency_rate = abs(1 - (abs($math_elements['Reviewer A'] - $math_elements['Reviewer B']) + abs($math_elements['Reviewer A'] - $math_elements['Reviewer C'])) / 6);
    }
  }

  return $consistency_rate;
}

/**
 * Implements hook_workbench_moderation_transition().
 */
function sbac_report_workbench_moderation_transition($node, $previous_state, $new_state) {
  // Update "created" timestamp when resource is submitted for review.
  // This is to help the views display the contributed time correctly as well as filtering on the right the date range.
  if ($new_state == 'needs_review') {
    db_update('node')
      ->fields(array('created' => REQUEST_TIME))
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Preprocess for views_view_field.
 */
function sbac_report_preprocess_views_view_field(&$vars) {
  // Output for number of "contributed resources posted" using SUM(workbench_moderation_node_history_published) in view is incorrect.
  // (it's always either 1 or 0 even after setting the format to boolean).
  // Current workbench_moderation version: 7.x-1.3
  if ($vars['view']->current_display == 'resources_summary' && $vars['field']->field_alias == 'workbench_moderation_node_history_published') {
    $vars['output'] = $vars['row']->workbench_moderation_node_history_published;
  }
  // Alter the output for the Resource state
  // e.g: "Needs Review" to "Submitted",
  //      "Being Reviewed" to "In Review",
  //      "Published" to "Posted" or "Posted with Distinction".
  elseif ($vars['view']->current_display == 'resources_details') {
    if ($vars['field']->field_alias == 'workbench_moderation_node_history_state') {
      $state = $vars['row']->workbench_moderation_node_history_state;
      if ($state == 'needs_review') {
        $vars['output'] = t('Submitted');
      }
      elseif ($state == 'being_reviewed') {
        $vars['output'] = t('In Review');
      }
      elseif ($state == 'published') {
        $vars['output'] = t('Posted');
        if ($vars['row']->node_sticky == 1) {
          $vars['output'] = t('Posted with Distinction');
        }
      }
    }
  }
}
